<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">






<link rel="stylesheet" href="/css/main.css?v=7.2.0">






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">








<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="博学之,审问之,慎思之,明辨之,笃行之">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="博学之,审问之,慎思之,明辨之,笃行之">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="博学之,审问之,慎思之,明辨之,笃行之">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>博学之,审问之,慎思之,明辨之,笃行之</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博学之,审问之,慎思之,明辨之,笃行之</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">aaaaltaaaaの博客</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/第四讲无线局域网/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/第四讲无线局域网/" class="post-title-link" itemprop="url">无线局域网</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:58" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="无线局域网概述"><a href="#无线局域网概述" class="headerlink" title="无线局域网概述"></a>无线局域网概述</h2><p>​    1.电磁波传播过程：由变化的电场激发变化的磁场，再由变化的磁场激发新的变化的电场，这种由近及远，不断继续下去的激发过程。</p>
<p>​    2.二进制位流转换成电磁波</p>
<ol start="3">
<li><p>无线信道 自由空间传播电磁波需要占据一段频段，这段频段就是无线信道。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<p>ISM频段</p>
<p>​    电磁波在网络通信中得到应用</p>
<p>​    在工业，科学和医疗 industrial，scientific，and medical 等领域也得到广泛应用</p>
<p>​    电磁波频率和发射功率严格空值，每个国家都有权威机构负责，比如我们国家的无线电管理委员会。</p>
<p>​    开放一些电磁波频段让公众自由使用，各国尽量将开放的电磁波频段一致，促使相关设备标准化。</p>
<p>电磁波的特点</p>
<p>​    能量损耗，能量损耗与传播距离平方成正比</p>
<p>​    干扰，尤其是ISM频段</p>
<p>​    多径效应</p>
<p>​    隐蔽站问题  暴露站问题</p>
<p>综合以上的特点，与有线通信的主要不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="无线局域网体系结构"><a href="#无线局域网体系结构" class="headerlink" title="无线局域网体系结构"></a>无线局域网体系结构</h2><p>基于以太网的TCP/IP 体系结构 </p>
<p>以太网： 物理层 MAC层</p>
<p> TCP/IP体系结构  </p>
<p>无线局域网  物理层  MAC子层 LLC子层</p>
<p>​    逻辑链路控制子层：指定数据类型</p>
<p>​    MAC子层：MAC地址  MAC封装 征用无线信道</p>
<p>​    物理层： 无线信道二进制位流传输功能</p>
<p>无线局域网表示数据类型的方式</p>
<p>DIX  定义的以太网标准中 MAC 有数据类型</p>
<p>IEEE   定义的局域网标准的MAC帧无数据类型</p>
</li>
</ol>
<p>   以太网采用DIX定义的标准  无需LLC子层</p>
<p>   ​    </p>
<h2 id="无线局域网组网方式"><a href="#无线局域网组网方式" class="headerlink" title="无线局域网组网方式"></a>无线局域网组网方式</h2><p>独立基本服务集IBSS                                              </p>
<p>​    无线局域网最小的构成单位是基本服务集</p>
<p>​    基本服务集中只包含工作站的称为独立基本服务集IBSS</p>
<p>​    包含工作站和AP的称为基本服务集合BSS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="无线局域网的MAC帧"><a href="#无线局域网的MAC帧" class="headerlink" title="无线局域网的MAC帧"></a>无线局域网的MAC帧</h2><p>​    MAC帧格式</p>
<p>​    以太网MAC帧一般帧结构</p>
<p>​    先导码 | 帧开始分界符 |目的地址 | 源地址 |类型 | 数据 |FCS</p>
<p>​    无线局域网MAC帧一般帧结构</p>
<p>​    先导码| 帧控制 | 持续时间| 关联标识符| 地址1 | 地址2 | 地址3| 顺序控制| 地址4 |数据| FCS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">帧控制</span><br><span class="line">	2b 2b 4b 1b 1b 1b 1b 1b 1b 1b 1b</span><br><span class="line">	协议版本，类型，子类型，到DS，从DS---</span><br></pre></td></tr></table></figure>

<p>无线局域网MAC帧分为控制，管理和数据三种类型。</p>
<p>采用四个地址字段是逐段确认所要求的，四个地址字段的含义与“到DS” “从DS”有关。</p>
<p>持续时间字段用于预留无线信道</p>
<p>顺序控制字段用于解决接收端MAC帧重复接受的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">IBSS</span><br><span class="line">	MAC帧中的地址：</span><br><span class="line">	地址1字段是目的中断MAC地址</span><br><span class="line">	地址2字段是源终端MAC地址</span><br><span class="line">	地址3字段是BSSID</span><br><span class="line">	“到DS”“从DS”位两位控制位分别为0和0</span><br><span class="line">	BSSID称为基本服务集标识符(Basic Service Set IDentification,简称BSSID)，是创建IBSS时产生的48位随机数，用于唯一标识该IBSS。</span><br><span class="line">	</span><br><span class="line">BSS</span><br><span class="line">	源终端A-&gt;AP:</span><br><span class="line">	地址1字段是AP 的MAC地址，接收端地址</span><br><span class="line">	地址2是源中端A地址</span><br><span class="line">	地址3是目的终端B地址</span><br><span class="line">	“到DS” 位和“从DS”位分别置为1和0</span><br><span class="line">	</span><br><span class="line">	AP-&gt;目的终端B</span><br><span class="line">	地址1字段是目的终端B的MAC地址</span><br><span class="line">	地址2是AP的MAC地址</span><br><span class="line">	地址3是源终端A地址</span><br><span class="line">	到DS 和从DS 分别置为0和1；</span><br><span class="line">	</span><br><span class="line">ESS</span><br><span class="line">WDS无线链路之间传输：</span><br><span class="line">源终端A --   X----无线网桥1（发送端）--------无线网桥2（接收端）---X---目的终端F</span><br><span class="line">	地址1字段是接收端地址，即无线网桥2的MAC地址</span><br><span class="line">	地址2字段是发送端地址，即不限吴桥1的地址</span><br><span class="line">	地址3字段是目的终端地址，即中断F的MAC地址</span><br><span class="line">	地址4是源中断地址，即终端AdequateMAC地址</span><br><span class="line">	”到DS“ 和 ”从DS“都是1</span><br><span class="line"></span><br><span class="line">AP-repeater模式</span><br><span class="line">AP1到AP2：</span><br><span class="line">	地址2字段是接收端地址，即AP2的MAC地址</span><br><span class="line">	地址2字段是发送端地址，即AP1的MAC地址</span><br><span class="line">	地址3字段是目的终端地址，即终端C的MAC地址</span><br><span class="line">	地址4字段是源终端地址，即终端A的MAC地址</span><br><span class="line">	到&quot;DS&quot;位和”从DS“位两位控制位都置为1</span><br><span class="line"></span><br><span class="line">地址字段含义</span><br><span class="line">	不同应用方式下四个地址字段值的含义一览表</span><br><span class="line">应用方式| 到DS |从DS |地址1       | 地址2     | 地址3      | 地址4</span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">IBSS   | 0    | 0   |目的终端地址 | 源终端地址| BSSID      |无</span><br></pre></td></tr></table></figure>

<h2 id="DCF和CSMA-CA"><a href="#DCF和CSMA-CA" class="headerlink" title="DCF和CSMA/CA"></a>DCF和CSMA/CA</h2><p>分布协调功能 DCF</p>
<p>无线局域网MAC层功能–&gt;多点接入控制{</p>
<p>​    分布协调功能(DCF)</p>
<p>​    终端自由平等竞争无线信道 IBSS BSS 这项功能必选</p>
<p>​    点协调功能PCF</p>
<p>​    AP用询问的方式分配信道 BSS 可选</p>
<p>}</p>
<p>DCF</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">建立终端自由平等竞争无线信道机制</span><br><span class="line">	载波侦听多点接入/冲突避免 机制</span><br><span class="line">	Carrier Sense Multiple Access/ Collision Avoidance</span><br><span class="line">归纳如下：</span><br><span class="line">	(1)若站点最初有数据要发送，且检测到信道空闲，在等待时间DIFS后，就发送整个数据帧。</span><br><span class="line">	(2)否则站点执行退避算法，如果检测到信号忙，那么冻结退避时间计时器，只要信道空闲，则继续计时。</span><br><span class="line">	(3)当退避时间减少到0，站点就发送整个的帧并等待确认</span><br><span class="line">	(4)发送站若接收到确认，就知道自己已经发送的帧被目的站正确接受到了，这是如果要发送第二帧，就从上面步骤2开始，</span><br><span class="line">	</span><br><span class="line">	如果源站没有在规定的时间内确认帧ACK，就必须重传此帧，直到收到确认为止，或者经过若干次的重传失败后放弃发送。</span><br><span class="line">	当一个站要发送数据帧时，仅在下面的情况下才不使用退避算法：检测到信道是空闲的，并且这个数据帧是它想发送的第一个数据帧。</span><br><span class="line">	具体来说，以下几种情况都必须使用退避算法</span><br><span class="line">	·在发送第一个帧之前检测到信道处于忙态</span><br><span class="line">	·每一次重穿传</span><br><span class="line">	~每一次的成功发送后再要发送下一帧。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">网络分配向量NAV</span><br><span class="line">	NAV是与无线网络协议，诸如IEEE802.11和IEEE802.16使用虚拟载波侦听机制。虚拟载波感测是它限制了需要物理载波感测在空中接口，以节省功率的逻辑抽象。MAC层帧头包含一个持续时间字段，用于指定需要的帧的传输时间，在这段时间内戒指将是忙，侦听无线戒指上的站读取的持续时间字段和设置其NAV，它适用于在多长时间必须按照访问的介质中的站的一个指标。</span><br><span class="line">	NAV的设计有助于解决无线局域网内冲突避免，是相对于物理载波监听的虚拟载波监听方法，通过帧格式中的duration来传送。</span><br><span class="line">	802.11之所以用CSMA/CA 而不是CD 是因为无线网中只能做到半双工，而不能同时发送又同时监听，所以也就不能像有线网络那样进行冲突检测了，只能想办法避免冲突。</span><br><span class="line">	</span><br><span class="line">信道空闲条件</span><br><span class="line">帧间间隔</span><br><span class="line">退避算法</span><br><span class="line">确认应答问题</span><br></pre></td></tr></table></figure>

<p> 帧间间隔</p>
<p>​    帧间间隔长度：帧间间隔是终端在完成当前MAC帧发送后，进行下一个MAC帧发送前需要等待的一段事件，这段时间的长短取决于终端要发送的MAC帧的类型，有控制，管理和数据三种类型。</p>
<p>​    帧间间隔长度决定了MAC帧的发送优先级：帧间间隔越短，对应类型的MAC帧的发送优先级越高。</p>
<p>​    无线局域网为了对不同类型的MAC帧分配不同的优先级，确定了4种不同的帧间间隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RTS和CTS解决隐蔽站问题</p>
<p>​    终端A和AP之间时间代价增加了RST，CTS。</p>
<h2 id="4-4终端接入无限局域网"><a href="#4-4终端接入无限局域网" class="headerlink" title="4.4终端接入无限局域网"></a>4.4终端接入无限局域网</h2><p>BSS配置过程</p>
<p>终端与AP同步过程</p>
<p>AP鉴别终端过程</p>
<p>终端与AP建立关联</p>
<p>BSS配置过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/第三讲以太网/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/第三讲以太网/" class="post-title-link" itemprop="url">以太网</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:56" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="3-1-内容简介"><a href="#3-1-内容简介" class="headerlink" title="3.1 内容简介"></a>3.1 内容简介</h1><p>​    互联网是由不同类型的传输网络互联而成的网际网。</p>
<p>​    以太网就是其中一种传输网络。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="以太网的发展过程"><a href="#以太网的发展过程" class="headerlink" title="以太网的发展过程"></a>以太网的发展过程</h2><h4 id="1-传输媒体从采用同轴电缆到双绞线缆和光纤"><a href="#1-传输媒体从采用同轴电缆到双绞线缆和光纤" class="headerlink" title="1.传输媒体从采用同轴电缆到双绞线缆和光纤"></a>1.传输媒体从采用同轴电缆到双绞线缆和光纤</h4><p>​    同轴电缆柔软性不够，不容易布线。</p>
<p>​    双绞线和光纤是两种互补性很强的传输媒体</p>
<p>​    这两种传输媒体的使用催生了一个新兴行业：综合布线    </p>
<h4 id="2-从共享式以太网发展到交换式以太网"><a href="#2-从共享式以太网发展到交换式以太网" class="headerlink" title="2.从共享式以太网发展到交换式以太网"></a>2.从共享式以太网发展到交换式以太网</h4><p>​    最初以太网是总线型以太网，也称共享式以太网。</p>
<p>​    交换式以太网是以太网是以太网发展过程的一个里程碑。</p>
<p>​    but，广播转发，造成资源浪费和安全问题</p>
<p>​    —&gt;VLAN技术的出现</p>
<h4 id="3-出现VLAN和三层交换技术"><a href="#3-出现VLAN和三层交换技术" class="headerlink" title="3.出现VLAN和三层交换技术"></a>3.出现VLAN和三层交换技术</h4><p>​    VLAN技术的出现很好的降低了广播所造成的危害。</p>
<p>​    VLAN之间的通信？？？ </p>
<p>​    三层交换机完美解决了以太网VLAN划分，VLAN内通信和VLAN间通信的问题。</p>
<h4 id="4-从低速以太网发展到高速以太网"><a href="#4-从低速以太网发展到高速以太网" class="headerlink" title="4.从低速以太网发展到高速以太网"></a>4.从低速以太网发展到高速以太网</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="3-2-总线型以太网"><a href="#3-2-总线型以太网" class="headerlink" title="3.2 总线型以太网"></a>3.2 总线型以太网</h1><h2 id="3-2-1总线型以太网基础"><a href="#3-2-1总线型以太网基础" class="headerlink" title="3.2.1总线型以太网基础"></a>3.2.1总线型以太网基础</h2><p> 拓扑结构+<strong>功能需求</strong>+体系结构</p>
<p><img src="C:%5CUsers%5C76639%5CAppData%5CLocal%5CTemp%5C1553784655679.png" alt="1553784655679"></p>
<h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><p>​    距离问题：互联起来的终端对距离的要求？</p>
<p>​    利用中继器完成信号的再生，从信号传播角度来说，只要不断增加中继器，总线的长度是无限的。</p>
<h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><p>​    对于发送终端来说;</p>
<p>​        ·发什么？怎么发？什么时候发？</p>
<p>​    对于receive terminal ：</p>
<p>​        ·收什么？怎么收？什么时候来收？由谁来收？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">数据封装：</span><br><span class="line">	数据封装用来解决发送什么的问题，数据加上辅助信息形成了帧，发送端以帧为单位发送，接受端以帧为单位接受。</span><br><span class="line">	</span><br><span class="line">数据与信号转换：</span><br><span class="line">	发送teminal将构成帧的二进制位流转换为信号</span><br><span class="line">	接受终端，把从总线上接受到的信号转换成一串二进制位流。</span><br><span class="line"></span><br><span class="line">帧对界：</span><br><span class="line">	解决怎么收，接受terminal要从一串二进制位流中正确提取出每一帧。</span><br><span class="line">	</span><br><span class="line">检测总线状态：</span><br><span class="line">	send terminal 必须要再总线空闲的时候才发送，同样的receive terminal 要在总线上由数据才接受。（总线状态空闲是必要条件）</span><br><span class="line">	总线型以太网是  半双工通信（■■■■）</span><br><span class="line"></span><br><span class="line">公平竞争的总线机制：</span><br><span class="line">	需要由一种机制保证只有一个terminal发送数据，而且每一个terminal成功发送数据的几率还要是均等的。</span><br><span class="line">	</span><br><span class="line">寻址：</span><br><span class="line">	解决谁来收···</span><br><span class="line">	每一个终端要正确判断自己是否是数据的接收者，确定自己是数据的接收者的时候才进行接受</span><br></pre></td></tr></table></figure>

<h3 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">网络是分层的不同的功能层完成不同的功能，最底层根据传输网络的不同而不同，</span><br><span class="line">当最底层位以太网的分为MAC层和物理层。</span><br><span class="line">物理层：帧对界，数据与信号的转换，检测总线的状态</span><br><span class="line">MAC层：寻址，公平竞争总线和数据封装。</span><br></pre></td></tr></table></figure>

<h1 id="3-2-2基带传输与曼彻斯特编码"><a href="#3-2-2基带传输与曼彻斯特编码" class="headerlink" title="3.2.2基带传输与曼彻斯特编码"></a>3.2.2基带传输与曼彻斯特编码</h1><h2 id="什么是基带传输"><a href="#什么是基带传输" class="headerlink" title="什么是基带传输"></a>什么是基带传输</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基带传输就是用基带信号实现数据传输方式。</span><br><span class="line">基带信号就是幅度只有两种离散值的数字信号。</span><br></pre></td></tr></table></figure>

<h2 id="如何用基带信号表示和还原数据？"><a href="#如何用基带信号表示和还原数据？" class="headerlink" title="如何用基带信号表示和还原数据？"></a>如何用基带信号表示和还原数据？</h2><p>​    二进制数的单位是二进制位，基带信号的单位是码元。对基带信号来说，码元就是一个二进制位所对应的信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">基带信号幅度：由人工确定 如+/- 0.7V</span><br><span class="line">宽度？</span><br><span class="line">码元长度与数据传输速率有关</span><br><span class="line">数据传输速率：10Mbps</span><br><span class="line">则每秒传输10M位二进制位</span><br><span class="line">基带信号每秒产生10M个码元</span><br><span class="line">那么码元长度（1/1E7）s</span><br></pre></td></tr></table></figure>

<pre><code>时钟：时钟是时间间隔相同的一串方波。单位时间内的方波数称为时钟频率</code></pre><p>每一个方波的长度称为时钟周期。</p>
<p><img src="C:%5CUsers%5C76639%5CAppData%5CLocal%5CTemp%5C1553837896183.png" alt="1553837896183"></p>
<p><img src="C:%5CUsers%5C76639%5CAppData%5CLocal%5CTemp%5C1553843587428.png" alt="1553843587428"></p>
<p><img src="C:%5CUsers%5C76639%5CAppData%5CLocal%5CTemp%5C1553843754388.png" alt="1553843754388"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">积累误差；</span><br><span class="line">接收端隔几位校正一次，指的是，让接收端的时钟周期开始位置与码元的开始位置一致，码元的开始位置可以通过跳变让接收端检测到</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">曼彻斯特编码</span><br><span class="line">  0  前高后低</span><br><span class="line">  1  前低后高</span><br><span class="line">  波特率=  2*数据传输速率，对信道带宽的要求提高了。当传输速率提高到100Mbps以上时，不用曼彻斯特编码。</span><br></pre></td></tr></table></figure>

<h1 id="3-2-3数据封装格式-MAC帧-smile-cat"><a href="#3-2-3数据封装格式-MAC帧-smile-cat" class="headerlink" title="3.2.3数据封装格式:MAC帧 :smile_cat:"></a>3.2.3数据封装格式:MAC帧 :smile_cat:</h1><h2 id="3-4-1mac地址"><a href="#3-4-1mac地址" class="headerlink" title="3.4.1mac地址"></a>3.4.1mac地址</h2><p><strong>网卡地址</strong> <strong>全球唯一</strong>  <strong>6个字节</strong></p>
<p>最后一位为0  单播地址，表示给某一个终端发送数据</p>
<p>最后一位为1  组播地址，给一组终端发送数据</p>
<p>FFFF FFFF FFFF   给总线上所有终端发送数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">目的地址+源地址+数据</span><br><span class="line">由于数据类型很多 IP  ARP等等</span><br><span class="line">所以增加一个数据类型</span><br><span class="line">为了检测是否正确 加一个FCS</span><br><span class="line">目的+源+数据类型+数据+FCS</span><br><span class="line"></span><br><span class="line">数据  46-1500字节</span><br><span class="line">为什么要设置上限？？？</span><br><span class="line">1. 接收端的缓存空间是有限的，每次发送的数据不能太长</span><br><span class="line">2.发送的数据太长的话，一旦发送失败，损失特别大</span><br><span class="line">3.每个终端一次不能占用太长时间</span><br><span class="line"></span><br><span class="line">下限？ 与冲突域有关</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">帧对界</span><br><span class="line">总线的状态  空闲状态+曼彻斯特编码</span><br><span class="line">·曼彻斯特编码使得总线数据传输状态和空间状态是不同的</span><br><span class="line">·两个帧之间至少存在一段总线空闲时间。</span><br><span class="line"></span><br><span class="line">要把属于每一帧的二进制位流分隔开。</span><br><span class="line"></span><br><span class="line">MAC层为了实现物理层的帧对界的功能，在MAC帧前面加上一个先导码和帧开始分界符。</span><br><span class="line"></span><br><span class="line">先导码  7字节的10101010组成的一组编码  ---&gt;接收端进行位同步</span><br><span class="line">帧开始分界符   一字节的  10101011  </span><br><span class="line"></span><br><span class="line">sum up</span><br><span class="line">先导码+帧开始定界符号+目的地址MAC+源地址+数据类型+数据+FCS</span><br></pre></td></tr></table></figure>

<h1 id="3-2-4CSMA-CD算法"><a href="#3-2-4CSMA-CD算法" class="headerlink" title="3.2.4CSMA/CD算法"></a>3.2.4CSMA/CD算法</h1><h2 id="工作步骤"><a href="#工作步骤" class="headerlink" title="工作步骤"></a>工作步骤</h2><p>​      <strong>C</strong>arrie <strong>S</strong>ense <strong>M</strong>ultiple <strong>A</strong>ccess with <strong>C</strong>ollision <strong>D</strong>etection</p>
<p>载波侦听：   检测总线上是否有载波</p>
<p>多点接入：   指可以有多个终端链接到总线上</p>
<p>冲突检测：   检测总线上是否发生冲突</p>
<p>因为总线型以太网式半双工模式，任何时候只能有一个终端发送信息，如果同时多个发送信息就会产生冲突。</p>
<p>先听再讲：</p>
<p>​    侦听总线上是否有载波，总线无载波才能发送数据。有载波就继续监听</p>
<p>等待帧间最小间隔</p>
<p>​    目的：留出时间让接收终端腾出缓冲空间</p>
<p>​        避免一个终端连续发送多个MAC帧</p>
<p>​        让终端正确检测到先导码和帧开始分界符。</p>
<p>边听边讲：</p>
<p>​    一边发送数据，一边检测是否发生冲突，如果发生冲突，采取相应措施</p>
<p>​    如果发生冲突，那么发送一个阻塞信号，告诉总线上的终端，有冲突发生。</p>
<p>退后再说：</p>
<p>​    按照后退策略延迟</p>
<h2 id="后退算法"><a href="#后退算法" class="headerlink" title="后退算法"></a>后退算法</h2><ol>
<li>K为冲突次数（注意冲突次数是针对同一个MAC帧来说的），初始时，K=0，每发生一次冲突，k++，但是K&lt;=10， 故K = min（冲突次数，10）</li>
<li>从整数集合【0 ,1,2,3…….,2^k-1】中随机选一个整数R</li>
<li>根据r，计算出后退时间T =  t*r （t 协议规定时间，不同传输速率t不同）</li>
<li>如果某个终端连续重传了16次都检测到冲突，则终止传输，并像高层协议报告  </li>
</ol>
<p>自适应后退算法，少量终端发生冲突，减少终端的平均延迟时间，大量终端发生冲突，不断增大整数集合，使得有终端能够得到发送数据的机会。</p>
<h2 id="3-2-5CSMA-CD算法缺陷"><a href="#3-2-5CSMA-CD算法缺陷" class="headerlink" title="3.2.5CSMA/CD算法缺陷"></a>3.2.5CSMA/CD算法缺陷</h2><p> 1.只适合轻负荷情况</p>
<p>​    网络负荷：某一段时间内连接在总线上的终端需要通过总线发送的数据总量</p>
<p>​    总线上5个终端同时发送数据，发生冲突则2^k-1 = 1</p>
<p>​    终端A和终端D延迟相同，结果又发生冲突</p>
<p>​    终端BCD三个终端的延迟时间又相同，再次发生冲突</p>
<p>​    那么终端要么与别的终端冲突中，要么处于等待中，总线的利用率很低        </p>
<p>2.存在捕获效应（一个一直发，另外一个一直发不了）</p>
<p>3.CSMA/CD存在最短帧长与冲突域直径之间的制约</p>
<p>​    冲突域，发生冲突的区域，最远两个终端的距离，叫做冲突域直径</p>
<p>​    设R是冲突域直径，t是信号在R之间传输的时间，无中继器的情况下，t和R之间的关系</p>
<p><strong>R=tC2/3</strong></p>
<p>则 时间2t，最坏情况，终端A在终端B处发生冲突，从发送到检测 经过了时间2t</p>
<p>一边发一遍监听，那么你发送一帧的时间必须大于2t。</p>
<p>结论：如果冲突域直径t, 终端A的每一帧的发送时间必须大于等于2t</p>
<h5 id="最短帧长"><a href="#最短帧长" class="headerlink" title="最短帧长"></a>最短帧长</h5><p>发送时间为2t的MAC帧长度叫最短帧长</p>
<p>Lmin = 2tS</p>
<p>S为终端的发送速率</p>
<h4 id="冲突域直径与最短帧长之间的限制"><a href="#冲突域直径与最短帧长之间的限制" class="headerlink" title="冲突域直径与最短帧长之间的限制"></a>冲突域直径与最短帧长之间的限制</h4><p>如果t不变,则:<br> 10Mbps时, L min =2×25.6×10 -6 ×10 7 =512b=64B<br> 100Mbps时,L min =2×25.6×10 -6 ×10 8 =5120b=640B<br>如果最短帧长不变(L min =64B)<br> 10Mbps时, t=L min /(2×s)=512/(2×10 7 ) = 25.6s<br> 100Mbps时,t=L min /(2×s)=512/(2×10 8 ) = 2.56s<br>无中继器冲突域直径R=t×(2/3)c=512m</p>
<p>如果t不变,则:<br> 100Mbps时, L min =2×25.6×10 -6 ×10 8 =5120b=640B<br> 1000Mbps时,L min =2×25.6×10 -6 ×10 9 =51200b=6400B<br>如果最短帧长不变(L min =64B)<br> 100Mbps时,t=L min /(2×s)=512/(2×10 8 ) = 2.56s<br> 1000Mbps时,t=L min /(2×s)=512/(2×10 9 ) = 0.256s<br>无中继器冲突域直径R=t×(2/3)c=51.2m</p>
<h1 id="3-3网桥与冲突域分割"><a href="#3-3网桥与冲突域分割" class="headerlink" title="3.3网桥与冲突域分割"></a>3.3网桥与冲突域分割</h1><h2 id="网桥分割冲突域原理"><a href="#网桥分割冲突域原理" class="headerlink" title="网桥分割冲突域原理"></a>网桥分割冲突域原理</h2><p>​    对于前面提到的，总线型以太网CSMA/CD算法的缺陷，我们的解决思路有;</p>
<ol>
<li><p>减小终端</p>
</li>
<li><p>缩小冲突域直径，可以使得最短帧长不变。</p>
<p>​    把一个大的以太网的冲突域分割为若干个小的冲突域，让每个冲突域里的终端数量减少，距离缩短，然后用一个设备把这些冲突域连接起来，这个设备称为<strong>网桥</strong>，这就是网桥分割冲突域的基本原理。</p>
<p><strong>网桥</strong>工作在物理层和数据链路层。 用作物理层设备时，它重新生成接收到的信号，</p>
<p>用作数据链路层设备时，它可以检查帧所包含的MAC地址。</p>
<p>网桥具有<strong>能力</strong>，它检查帧的目的地址，并决定该帧被转发或丢弃，转发帧时必须指定端口，每个网桥都有一个端口地址映射表。</p>
<p>:bookmark:  <strong>hub</strong>是一个多端口的中继器，它通常用于星型拓扑结构。</p>
<p>:bookmark: <strong>中继器</strong>是仅工作在物理层的设备，网络内携带信息的信号在衰减到危及数据完整性之前，可以传输一段固定的距离，中继器接收信号，并且在信号变得很弱或者被破坏之间，重新生成原始的位模式，然后中继器发送新生成的信号，中继器能够扩展局域网的物理长度。</p>
</li>
</ol>
<h2 id="转发表和MAC帧转发过程"><a href="#转发表和MAC帧转发过程" class="headerlink" title="转发表和MAC帧转发过程"></a>转发表和MAC帧转发过程</h2><h2 id="网桥的工作流程"><a href="#网桥的工作流程" class="headerlink" title="网桥的工作流程"></a>网桥的工作流程</h2><h1 id="3-4交换式以太网和VLAN"><a href="#3-4交换式以太网和VLAN" class="headerlink" title="3.4交换式以太网和VLAN"></a>3.4交换式以太网和VLAN</h1><h2 id="VLAN与广播域分割"><a href="#VLAN与广播域分割" class="headerlink" title="VLAN与广播域分割"></a>VLAN与广播域分割</h2><h3 id="什么是广播域"><a href="#什么是广播域" class="headerlink" title="什么是广播域"></a>什么是广播域</h3><p>· 广播域是指所有的网桥以广播方式输出MAC帧时，MAC帧遍历的网络范围。</p>
<p>·冲突域中，不管目的地址类型，都是采用广播方式转发，</p>
<h3 id="广播存在哪些危害"><a href="#广播存在哪些危害" class="headerlink" title="广播存在哪些危害"></a>广播存在哪些危害</h3><p>·浪费网络链路带宽，浪费网桥，终端的处理能力。</p>
<p>·引发安全问题。</p>
<p>网桥在那种情况下存在广播？？？？</p>
<p>1.建立转发表之间，广播</p>
<p>2.大量网络协议都是广播协议，广播</p>
<h3 id="引入VLAN的原因"><a href="#引入VLAN的原因" class="headerlink" title="引入VLAN的原因"></a>引入VLAN的原因</h3><p>广播是不可避免的，但是又存在危害。how to do？</p>
<p>缩小广播域： 减小资源浪费，避免引发安全问题（相同工作特性，相同安全等级）</p>
<p>划分应该满足： </p>
<p>·1物理位置无关性。</p>
<p>·2广播范围动态性。</p>
<h3 id="什么是VLAN"><a href="#什么是VLAN" class="headerlink" title="什么是VLAN"></a>什么是VLAN</h3><p>​        <strong>物理以太网产生的每一个广播域等同于一个逻辑上独立的以太网，由于这些逻辑上独立的以太网存在于同一个物理以太网中，因而被称为虚拟局域网 VLAN</strong></p>
<p>``vlan的特性<br>划分VLAN不需要改变以太网的物理结构，<br>改变VLAN不需要改变以太网的物理结构<br>终端归属于哪个VLAN： 与终端在物理以太网中的位置无关。</p>
<h3 id="VLAN划分的过程"><a href="#VLAN划分的过程" class="headerlink" title="VLAN划分的过程"></a>VLAN划分的过程</h3><p><strong>网桥</strong>：以太网中常常把网桥称为以太网交换机。为了学习方便，具有地址学习、MAC帧转发等分组交换功能的设备。</p>
<p><strong>以太网交换机</strong>：在网桥基础上，增加了VLAN划分及其他一些增强网络性能的功能的设备。</p>
<p>以交换机为分组交换设备构建的以太网称为<strong>交换式以太网</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="单交换机VLAN划分过程"><a href="#单交换机VLAN划分过程" class="headerlink" title="单交换机VLAN划分过程"></a>单交换机VLAN划分过程</h2><h3 id="为VLAN分配端口"><a href="#为VLAN分配端口" class="headerlink" title="为VLAN分配端口"></a>为VLAN分配端口</h3><p>​    默认情况下，交换机所有端口属于同一个广播域。      </p>
<h3 id="建立端口之间的交换路径"><a href="#建立端口之间的交换路径" class="headerlink" title="建立端口之间的交换路径"></a>建立端口之间的交换路径</h3><h3 id="确定MAC帧所属的VLAN"><a href="#确定MAC帧所属的VLAN" class="headerlink" title="确定MAC帧所属的VLAN"></a>确定MAC帧所属的VLAN</h3><h2 id="跨交换机VLAN划分"><a href="#跨交换机VLAN划分" class="headerlink" title="跨交换机VLAN划分"></a>跨交换机VLAN划分</h2><h3 id="端口配置原则"><a href="#端口配置原则" class="headerlink" title="端口配置原则"></a>端口配置原则</h3><p>·将物理以太网中不同交换机中的任意端口组合分配到某个vlan中。</p>
<p>·建立这些交换机端口之间的交换路径。</p>
<p>允许将不同交换机的多个端口分配到同一个vlan。</p>
<p>必须保证任何两个属于同一个vlan之间的端口存在<strong>交换路径</strong>;</p>
<p><strong>存在问题</strong>：</p>
<p>​    交换机端口浪费，每个跨交换机的vlan都要有两个端口用来建立交换机之间的交换路径；</p>
<p>​    交换机之间的物理链路数量是不确定的，随着跨交换机VLAN数量的变化而变化。</p>
<h3 id="802-1Q"><a href="#802-1Q" class="headerlink" title="802.1Q"></a>802.1Q</h3><p>目的地址|源地址|VLAN标记|类型|数据|FCS；</p>
<p>其中VLAN标记  |8100H|    |  VLAN ID|</p>
<h3 id="VLAN内MAC帧传输过程"><a href="#VLAN内MAC帧传输过程" class="headerlink" title="VLAN内MAC帧传输过程"></a>VLAN内MAC帧传输过程</h3><p>交换机1根据连接终端A的端口确定该MAC帧属于VLAN2， <strong>标记上VLAN2标志符</strong>，从共享端口发送出去</p>
<p>交换机2从共享端口根据mac帧VLAN标识符确定MAC帧属于VLAN2，交由组成VLAN2的网桥转发。</p>
<h3 id="确定MAC帧所属VLAN规则"><a href="#确定MAC帧所属VLAN规则" class="headerlink" title="确定MAC帧所属VLAN规则"></a>确定MAC帧所属VLAN规则</h3><p>共享端口：同时属于多个VLAN。</p>
<p>接入端口：只属于单个VLAN</p>
<p>混合端口：具有共享端口和接入端口双重功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">共享端口</span><br><span class="line"></span><br><span class="line">mac帧需要携带VLAN标识符</span><br><span class="line"></span><br><span class="line">携带的VLAN标识符与共享端口所属的vlan范围一直</span><br><span class="line"></span><br><span class="line">根据MAC帧携带的VLAN标识符确定该MAC帧属于的VLAN；</span><br><span class="line"></span><br><span class="line">接入端口</span><br><span class="line"></span><br><span class="line">##MAC帧不能携带VLAN标识符##</span><br><span class="line"></span><br><span class="line">根据输入MAC帧的端口确定该MAC帧所属VLAN。</span><br><span class="line"></span><br><span class="line">混合端口</span><br><span class="line">·对于携带VLAN标识符的 MAC帧，且携带的VLAN标识符与共享端口所属的vlan范围一致，根据MAC帧携带的VLAN标识符确定VLAN</span><br><span class="line">·对于没有携带VLAN标识符的MAC帧，根据输入MAC帧的端口确定该MAC帧的VLAN。</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/操作符重载/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/操作符重载/" class="post-title-link" itemprop="url">操作符重载</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:47" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#　四则运算符重载</p>
<p>设计一个数偶类，定义专用的四则运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Couple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Couple(<span class="keyword">int</span> a =<span class="number">0</span>,<span class="keyword">int</span> b = <span class="number">0</span>):_a(a),_b(b)&#123;&#125;</span><br><span class="line">    Couple <span class="keyword">operator</span>+ (<span class="keyword">const</span> Couple &amp; c); <span class="comment">//实际上用了两个成员，一个是本身</span></span><br><span class="line">    Couple <span class="keyword">operator</span>*(<span class="keyword">const</span> Couple &amp;c);</span><br><span class="line">    Couple <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">int</span> &amp;k);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a,_b;</span><br><span class="line">&#125;;</span><br><span class="line">Couple Couple::<span class="keyword">operator</span>+(<span class="keyword">const</span> Couple&amp;c)&#123;</span><br><span class="line">    Couple <span class="keyword">_t</span>(<span class="keyword">this</span>-&gt;_a+c._a,<span class="keyword">this</span>-&gt;_b+c._b);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">_t</span>;</span><br><span class="line">&#125;</span><br><span class="line">Couple Couple::<span class="keyword">operator</span>*(<span class="keyword">const</span> Couple&amp;c)&#123;</span><br><span class="line">    Couple <span class="keyword">_t</span>(<span class="keyword">this</span>-&gt;_a*c._a,<span class="keyword">this</span>-&gt;_b*c._b);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">_t</span>;</span><br><span class="line">&#125;</span><br><span class="line">Couple Couple::<span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">int</span> &amp;k)&#123;</span><br><span class="line">    Couple <span class="keyword">_t</span>(<span class="keyword">this</span>-&gt;_a*k,<span class="keyword">this</span>-&gt;_b*k);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">_t</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h4><p>参数必须是Couple类对象的常引用吗，？</p>
<p>可以不使用引用，但是会产生对象拷贝动作，降低效率</p>
<p>因为两种传递方式，一种是引用，一种就是值，如果不使用引用，</p>
<p>值传递会产生一个值的拷贝动作，降低效率，</p>
<p>也可以不是常引用，但是这会导致无法限制函数内部对参数的修改，。</p>
<p>可以使用指针，但与常规数学公式使用方式不符合</p>
<p>返回值必须是couple类的对象吗，返回引用可以吗？</p>
<p>可以返回引用，但是必须保证这个对象是在函数结束后还存在的，比如说，全局</p>
<p>否则，函数结束就没了@-＠</p>
<p>不能返回函数内部局部量的引用</p>
<p>所以不建议使用引用类作为返回值哦</p>
<p>－需要将右操作数累加到左操作数上并返回左操作数时候，此时应该重载加赋等操作，</p>
<p>这个时候返回引用是ｏｋ的，因为还是原来的那个</p>
<p>四则运算符必须重载为成员函数嘛</p>
<p>不，可以重载为类的友元函数或普通函数，普通函数无法访问类的私有成员</p>
<p>＝－建议重载为友元函数</p>
<p>重载为友元函数</p>
<p><strong>重载为友元函数</strong></p>
<p>优势：显示具有双操作数，且格式一致，操作不局限于</p>
<p>重载为普通函数，普通函数没有权利访问私有成员。</p>
<p>重载为友元函数，</p>
<p>优势：显示具有双操作数，且格式一致：操作不局限于当前对象本身，且不要求左操作数必须为本类的对象。</p>
<p>劣势：显示具有双操作数，不能省略做操作数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Couple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Couple(<span class="keyword">int</span> a = <span class="number">0</span>,<span class="keyword">int</span> b =<span class="number">0</span>):_a(a),_b(b)&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> Couple <span class="keyword">operator</span>+(<span class="keyword">const</span> Couple &amp;c1,<span class="keyword">const</span> Couple &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Couple <span class="keyword">operator</span>*(<span class="keyword">const</span> Couple &amp; c1,<span class="keyword">const</span> Couple &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> Couple <span class="keyword">operator</span>*(<span class="keyword">const</span> Couple &amp;c,<span class="keyword">const</span> <span class="keyword">int</span> &amp;k);</span><br><span class="line">    <span class="keyword">friend</span> Couple <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">int</span> &amp;k,<span class="keyword">const</span> Couple &amp; c);</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a,_b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>数偶倍乘运算重载的说明</strong></p>
<p>－应重载为类的友元函数</p>
<p>－如果非友元函数，当倍数为左操作数时候，无法解析乘法运算，编译回出错，</p>
<p>－将左操作数ｋ转换为Couple类的对象可以解决上述问题，但意义已经不同</p>
<p>－上述转换要求提供一个单参数的从整数到Couple类的构造函数，如果使用explicit修饰该构造函数，隐式类型转换会被禁止；虽然即使不禁止，很多编译器也不进行此转换。</p>
<p>－左右操作数不可互换，重载函数必须提供两个版本，它们的函数签名不同</p>
<h1 id="关系与下标操作符重载"><a href="#关系与下标操作符重载" class="headerlink" title="关系与下标操作符重载"></a>关系与下标操作符重载</h1><p>为数偶类定义专用的关系操作符。</p>
<p>以＝＝　和!=为例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Couple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Couple(<span class="keyword">int</span> a = <span class="number">0</span>,<span class="keyword">int</span> b =<span class="number">0</span>):_a(a),_b(b)&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Couple&amp;c1,<span class="keyword">const</span> Couple &amp;c2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Couple&amp;c1,<span class="keyword">const</span> Couple&amp;c2);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a,_b;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Couple &amp; c1,<span class="keyword">const</span> Couple &amp;c2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (c1._a==c2._a)&amp;&amp;(c1._b==c2._b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Couple &amp;c1,<span class="keyword">const</span> Couple &amp;c2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (c1._a!=c2._a)&amp;&amp;(c1._b!=c2._b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下标操作符重载的场合与目的</p>
<p>－如果对象具有数组成员，且该成员为主要成员，可以重载下标操作符</p>
<p>－目的，以允许在对象上通过数组下标访问该数组</p>
<p>－</p>
<p>下标操作符必须重载两个版本</p>
<p>－常函数版本用于处理常量</p>
<p><strong>一定要提供两个版本</strong></p>
<p>数组下标越界错误</p>
<p>－可以在重载函数中处理数组下标越界错误，或使用异常处理机制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Couple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Couple(<span class="keyword">int</span> a =<span class="number">0</span>,<span class="keyword">int</span> b =<span class="number">0</span>)&#123;_a[<span class="number">0</span>]=a,_a[<span class="number">1</span>]=b;&#125;</span><br><span class="line">    <span class="keyword">int</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; Couple::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span>||index&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Index is out of range!"</span>);</span><br><span class="line">    <span class="keyword">return</span> _a[index];</span><br><span class="line">&#125;</span><br><span class="line">cosnt <span class="keyword">int</span> &amp; Couple::<span class="keyword">operator</span>[](<span class="keyword">int</span> index )<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    it(index&lt;<span class="number">0</span>||index&gt;<span class="number">1</span>)</span><br><span class="line">       	<span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Index is out of range!"</span>);</span><br><span class="line">    <span class="keyword">return</span> _a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        Couple a(<span class="number">1</span>,<span class="number">2</span>),b(<span class="number">3</span>,<span class="number">4</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="built_in">cin</span>&gt;&gt;a[<span class="number">0</span>]&gt;&gt;a[<span class="number">1</span>];</span></span></span><br><span class="line"><span class="function"><span class="params">        </span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br></pre></td></tr></table></figure>

<p>主要行为不是数组就不要这样做了</p>
<p>　</p>
<h1 id="赋值操作符重载"><a href="#赋值操作符重载" class="headerlink" title="赋值操作符重载"></a>赋值操作符重载</h1><p>赋值操作符号重载的一般形式</p>
<p>符合赋值操作符重载</p>
<p>赋值构造与拷贝构造</p>
<p>浅拷贝与深拷贝</p>
<p>移动语义(c++11)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Couple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Couple( <span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span> ) : _a(a), _b(b)&#123; &#125;</span><br><span class="line">  Couple( <span class="keyword">const</span> Couple &amp; c ) : _a(c._a), _b(c._b)&#123; &#125;</span><br><span class="line">  Couple &amp; <span class="keyword">operator</span>=( <span class="keyword">const</span> Couple &amp; c );</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Couple&amp;c1,<span class="keyword">const</span> Couple &amp;c2);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> _a, _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Couple &amp; c1,<span class="keyword">const</span> Couple &amp;c2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (c1._a==c2._a)&amp;&amp;(c1._b==c2._b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Couple &amp; Couple::<span class="keyword">operator</span>=( <span class="keyword">const</span> Couple &amp; c )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>( *<span class="keyword">this</span> == c )</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  _a = c._a,  _b = c._b;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Couple a( 1, 2 ), b( 3, 4 );</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a._a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  a = b;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a._a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result:</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>###　赋值构造与拷贝构造</p>
<p>赋值也是拷贝</p>
<p>拷贝，赋值与析构三位一体，一般同时出现</p>
<p>－　缺省赋值构造与拷贝构造为浅拷贝</p>
<p>－如果对象没有指针成员，缺省行为即可满足要求，无需事先或重载这三个函数</p>
<p>如果对象有指针成员，一般需要重载这三个函数</p>
<p>浅拷贝的机制很多时候达不到你的要求，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A():_N(<span class="number">0</span>),_P(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    explicit A(int n):_n(n),_p(new int[n])&#123;&#125;//表示这是一个单参数的构造函数，ｅｘｐｌｉｃｉｔ　　除非我这做，你自己不要擅自这样。</span><br><span class="line">    A(<span class="keyword">int</span> n,<span class="keyword">int</span> *p):_n(n),_p(p)&#123;&#125;</span><br><span class="line">    A(cont A &amp;that):_n(that._n),_p(that._p)&#123;&#125;</span><br><span class="line">    A &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> A &amp;that)&#123;_n=that._n,_p=that._p;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~A()&#123;<span class="keyword">if</span>(_p)&#123;delele[] _p,_p=<span class="literal">NULL</span>;&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i );</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i )<span class="keyword">const</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _n;</span><br><span class="line">    <span class="keyword">int</span> *_p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>浅拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; A <span class="keyword">operator</span>[](<span class="keyword">int</span> i )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;<span class="number">0</span> || i&gt;=<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Out of range when trying to access the object..."</span>);</span><br><span class="line">    <span class="keyword">return</span> _p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; A::<span class="keyword">operator</span>[] (<span class="keyword">int</span> i )<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> ||i&gt;=<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Out of range when tring to access the object.."</span>);</span><br><span class="line">    <span class="keyword">return</span> _p[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是下标操作符的重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a(4),b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        a[i] = i+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Before object assignment:"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">""</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>:<span class="built_in">endl</span>;</span><br><span class="line">    b=a;<span class="comment">//注意此处，只能将a的数据成员一个接一个的复制过去</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"After object assignment:"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;b[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="built_in">std</span>:<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//程序结束，系统崩溃</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">一旦你的数据成员中有指针，浅拷贝需特别注意</span><br><span class="line"></span><br><span class="line">_n没有问题</span><br><span class="line"></span><br><span class="line">但是_p　　两个对象的两个字段，　都指向了同一片内存空间</span><br><span class="line"></span><br><span class="line">当ｍａｉｎ函数结束的试试，局部变量将要被销毁，那么将销毁ａ　　释放存储区</span><br><span class="line">然后尝试销毁ｂ　　发现ｂ不是ｎｕｌｌ　　销毁所指向的目标</span><br><span class="line">但是　ｂ　是一个空悬指针，因为已经销毁过了</span><br><span class="line">系统尝试ｂ上析构，崩溃｀｀｀</span><br><span class="line">这就是浅拷贝的语义导致的问题</span><br><span class="line"></span><br><span class="line">深拷贝</span><br><span class="line">不仅仅解决空悬指针的问题，</span><br><span class="line">我们要产生原始对象的完整副本。</span><br><span class="line">缺省的拷贝只能拷贝一个值，层次不够～｀｀</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A(<span class="keyword">const</span> A &amp;that);</span><br><span class="line">A &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> A &amp;that);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A:A(cont A &amp;that)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_n = that._n;</span><br><span class="line">    _p = <span class="keyword">new</span> <span class="keyword">int</span>[_n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        _p[i] = that._p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A &amp; A::<span class="keyword">operator</span> = (<span class="keyword">const</span> A &amp; that)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_n = that._n;</span><br><span class="line">    <span class="keyword">if</span>(_p)</span><br><span class="line">        <span class="keyword">delete</span>[] _p;</span><br><span class="line">    _p = <span class="keyword">new</span> <span class="keyword">int</span>[_n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        _p[i] = that._p[i];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的持有目标数组的所有权，所有权移交</p>
<p>ａ的ｐ赋值为空指针</p>
<p>不然双指针指向同一地方</p>
<h3 id="移动语义-c-11"><a href="#移动语义-c-11" class="headerlink" title="移动语义(c++11 +)"></a>移动语义(c++11 +)</h3><p>两个对象构造出来没问题，但是要求拷贝对象和赋值对象的时候，目标所有权需要移交</p>
<p>这就是移动语义</p>
<p>需要了解</p>
<p>左值与右值　　Ｖ　　Ａ　　　Ｎ　　Ｔ</p>
<p> VALUE  ADDRESS NAME TYPE</p>
<p>左值和右值实际上是编译器对待我们标识符的角度来看的</p>
<p>比如　ｘ　＝ｙ</p>
<p>取ｘ　和　ｙ　的左值　即地址</p>
<p>然后取ｙ的右值　即　地址存储的值</p>
<p>然后将与ｙ的值给ｘ</p>
<p>把刚刚放进去的值作为赋值表达式的结果。</p>
<p>这是ｃ的简单的赋值动作产生的效果</p>
<p>为了支持移动语义，在ｃ＋＋　１１　版本中做了变化</p>
<p>　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">c原始定义</span><br><span class="line">－左值：可以出现在赋值好左边或右边</span><br><span class="line">－右值：　只能出现在赋值号右边</span><br><span class="line"></span><br><span class="line">Ｃ＋＋定义</span><br><span class="line">－左值　：用于标识非临时对象或非成员函数的表达式</span><br><span class="line">－右值：用于标识临时对象的表达式或者　与任何对象无关的值，（纯右值</span><br><span class="line">，或者用于标识即将失效的对象的表达式　失效值</span><br></pre></td></tr></table></figure>

<p>左值引用：＆　　普通引用，</p>
<p>右值引用：＆＆</p>
<p>－深拷贝需要频繁分配和释放内存，效率较低</p>
<p>－移动语义的目的：所有权移交，不需要重新构造和析构</p>
<p>－为与构造函数兼容，移动语义必须为引用，而不能是指针或普通量</p>
<p>－普通引用传递左值，以允许函数内部修改目标数据对象。</p>
<p>－为了区分左值引用，实现移动语义时必须传递右值引用。</p>
<p>－为了保证能够修改目标数据对象，在函数内部必须将右值引用作为左值引用对待。</p>
<p>指针传递也是值传递　　值是个地址而已</p>
<h2 id="移动赋值与移动构造"><a href="#移动赋值与移动构造" class="headerlink" title="移动赋值与移动构造"></a>移动赋值与移动构造</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">      A(A&amp;&amp;that);</span><br><span class="line">      A &amp; <span class="keyword">operator</span> = (A &amp;&amp; that);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">A::A( A &amp;&amp; that )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//  nullptr：C++11预定义的空指针类型nullptr_t的常对象</span></span><br><span class="line">  <span class="comment">//  可隐式转换为任意指针类型和bool类型，但不能转换为整数类型，以取代NULL</span></span><br><span class="line">  _n = that._n,  _p = that._p,  that._n = <span class="number">0</span>,  that._p = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">//  *this = that;    //  此代码不会调用下面重载的赋值操作符函数</span></span><br><span class="line">  <span class="comment">//  具名右值引用that在函数内部被当作左值，不是右值</span></span><br><span class="line">  <span class="comment">//  匿名右值引用才会被当作右值；理论上如此……</span></span><br><span class="line">  <span class="comment">//  *this = static_cast&lt;A &amp;&amp;&gt;( that );    //  等价于 *this = std::move( that );</span></span><br><span class="line">  <span class="comment">//  上一行代码可以调用下面重载的移动赋值操作符，但是有可能导致程序崩溃</span></span><br><span class="line">  <span class="comment">//  因this指向的本对象可能刚刚分配内存，_p字段所指向的目标数据对象无定义</span></span><br><span class="line">&#125;</span><br><span class="line">A &amp; A::<span class="keyword">operator</span>=( A &amp;&amp; that )</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>( _p )    <span class="keyword">delete</span>[] _p;    <span class="comment">//  删除此行代码可能会导致内存泄露</span></span><br><span class="line">  <span class="comment">//  可以测试是否为同一对象，以避免自身复制操作，但意义不大</span></span><br><span class="line">  _n = that._n,   _p = that._p,  that._n = <span class="number">0</span>,  that._p = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A c(static_cast&lt;A &amp;&amp;&gt; (a));</span><br><span class="line">c = static_cast&lt;A &amp;&amp;&gt; (a);</span><br><span class="line">传递左值引用还是传递右值引用将决定调用那个函数</span><br></pre></td></tr></table></figure>

<h3 id="移动语义再认识"><a href="#移动语义再认识" class="headerlink" title="移动语义再认识"></a>移动语义再认识</h3><p>达到修改目的　左值也行，const 去掉就ＯＫ</p>
<p>右值引用的意义</p>
<p>可以作为文字作为函数实际参数。</p>
<p>避免编写过多的构造与赋值函数</p>
<p>无论是左值引用还是右值引用，如果同事提供拷贝语义和移动语义，需要２对</p>
<p>４个构造和赋值函数</p>
<p>－如果通过单独提供成员值的方式构造对象，单成员至少２对　４个</p>
<p>双成员至少４对　８个</p>
<p>－使用右值引用，通过函数模板可以减少代码编写量</p>
<p>实现完美转发</p>
<p>－如果通过</p>
<h1 id="流操作符重载"><a href="#流操作符重载" class="headerlink" title="流操作符重载"></a>流操作符重载</h1>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/安卓开发2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/安卓开发2/" class="post-title-link" itemprop="url">安卓开发2</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:44" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h2><p>​    一种可以包含用户界面的组件，主要用于和用户进行交互，一个应用程序中可以包含零个或多个活动。但不包含任何活动的应用程序很少见。</p>
<h2 id="活动的基本用法"><a href="#活动的基本用法" class="headerlink" title="活动的基本用法"></a>活动的基本用法</h2><p>   com.example.activitytest  -&gt;new -&gt;activity-&gt;empty Activity.   </p>
<p>without      generate layout file and launcher activity.</p>
<p>setContentView() 方法给当前活动加载一个布局，一般是传入布局id，项目中添加任何资源文件都会在R文件中生成一个相应的资源ID，因此我们刚才创建的first_layout.xml布局的id现在已经是添加到R文件中，R.layout.first_layout就可以得到该布局的id。</p>
<p>在AndroidManifest文件中注册</p>
<p> 实际上我们创建activity时，Android studio已经帮我们自动注册了。注册后，程序仍然不能运行，因为没有指定主活动，程序运行时不指导启动哪个活动，配置主活动的方法，在activity标签内部加上 intent-filter标签并且加上声明 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>除此之外，我们还可以使用android：label来指定活动中标题栏中的内容，标题栏是显示在活动最顶部的。</p>
<p>给主活动指定label不仅会成为标题栏的内容，还会称为启动器launcher中应用程序的名称。</p>
<h3 id="在活动中使用Toast"><a href="#在活动中使用Toast" class="headerlink" title="在活动中使用Toast"></a>在活动中使用Toast</h3><pre><code>Toast 是Android系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息通知给用户，这些信息会在一段时间后小时，并且不会暂用任何屏幕空间。</code></pre><p>​    首先需要定义一个弹出Toast的出发点，利用界面上的按钮，点击按钮弹出一个Toast。</p>
<p>​    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">button1.setOnClickListener(new View.OnClickListener()&#123;</span><br><span class="line">    public void onClick(View v)&#123;</span><br><span class="line">        Toast.makeText(FirstActivity.this,&quot;不是按钮，点了也没有用·-·&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">	在activity中，通过 findViewById()方法来获取当前布局文件中定义的元素，这里我们传入R.id.button_1,来得到按钮的实例，这个只是刚才在first_layout.xml中通过android:id属性指定的。</span><br><span class="line">	findViewById()方法返回的是一个view对象，我们需要向下转型，将他转成Button对象，得到按钮的实例后，我们通过调用setOnClickListener()方法为按钮注册一个监听器，点击按钮时就会执行监听器中的onClick()方法。</span><br><span class="line">	Toast的用法非常简单，通过静态方法makeText()创建出一个Toast对象，然后调用 show()将Toast显示出来就可以了，这里需要注意的时，</span><br><span class="line">		makeText()方法需要传入3个参数，第一个参数是Context，也就是Toast要求的上下文，由于活动本身就是一个context对象，因此这里直接传入FirstActiity.this即可。第二个参数是Toast显示的文本内容，第三个参数是Toast显示的时常，有两个内置常量可以选择，Toast.LENGTH_SHORT 和Toast.LENGTH_LONG</span><br><span class="line">		</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">## 在活动中使用Menu</span><br><span class="line"></span><br><span class="line">​	res-&gt;new -&gt;directory</span><br><span class="line"></span><br><span class="line">​	menu  OK    main   NEW-Menu resource file</span><br><span class="line"></span><br><span class="line">~~~xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">&lt;item android:id=&quot;@+id/add_item&quot;</span><br><span class="line">    android:title=&quot;Add&quot;/&gt;</span><br><span class="line">    &lt;item</span><br><span class="line">        android:id=&quot;@+id/remove_item&quot;</span><br><span class="line">        android:title=&quot;Remove&quot;/&gt;</span><br><span class="line">&lt;/menu&gt;</span><br><span class="line">创建了两个菜单项，其中&lt;/item&gt;标签来创建具体的某一项，指定标识符和名称。</span><br><span class="line"></span><br><span class="line">回到FirstActivity来重写onCreateOptionMenu()方法</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span> </span>&#123;</span><br><span class="line">        getMenuInflater().inflate(R.menu.main,menu);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">getMenuInflater 得到MenuInflater对象，再调用它的inflate方法就可以给当前活动创建菜单。</span><br><span class="line">inflate()方法接受两个参数，第一个用于指定我们通过哪个资源文件来创建菜单，传入R.menu.main</span><br><span class="line">第二个参数用于指定我们的菜单项将添加到哪一个menu对象中，这里直接使用onCreateOptionsMenu()方法中传入的menu参数，然后给这个方法返回<span class="keyword">true</span>，表示允许创建的菜单显示出来，如果返回了<span class="keyword">false</span>，创建的菜单将无法显示。</span><br><span class="line"></span><br><span class="line">接下来重新菜单响应事件。重写onOptionsItemSelected()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(item.getItemId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.add_item:</span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>,<span class="string">"You clicked Add"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.remove_item:</span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>,<span class="string">"you clicked remove"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">通过调用item.getItemId() 来判断我们点击的是哪一个菜单项，然后给每个菜单项加入自己的处理。</span><br></pre></td></tr></table></figure>

<h3 id="销毁一个活动"><a href="#销毁一个活动" class="headerlink" title="销毁一个活动"></a>销毁一个活动</h3><p>finish();</p>
<h2 id="2-3使用intent在活动之间穿梭"><a href="#2-3使用intent在活动之间穿梭" class="headerlink" title="2.3使用intent在活动之间穿梭"></a>2.3使用intent在活动之间穿梭</h2><p>​    Intent大致可以分为两种：显示intent和隐式intent；</p>
<p>​    Intent有多个构造函数的重载，其中一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent(Context packageContext, Class&lt;?&gt;cls)</span><br><span class="line">    Context， 提供一个启动活动的上下文，</span><br><span class="line">    Class，指定想要启动的目标活动。</span><br><span class="line">    Activity类中提供了一个startActivity()方法，这个方法专门用于启动活动，其接受一个intent参数，将构建好的intent传入startActivity()方法就可以启动目标活动了。</span><br><span class="line">    修改firstActivity中按钮的点击事件，代码如下：</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">首先构造了一个Intent，传入FirstActivity.<span class="keyword">this</span>作为上下文，传入Second-Activity.class作为目标活动。</span><br><span class="line">这种称之为显示intent</span><br></pre></td></tr></table></figure>

<h2 id="2-3-2隐式Intent"><a href="#2-3-2隐式Intent" class="headerlink" title="2.3.2隐式Intent"></a>2.3.2隐式Intent</h2><p>​    相比于显示Intent，隐式Intent则含蓄了很多，它并不明确指出我们想要启动哪一个活动，而是指定一系列更为抽象的action和category等信息，然后交由系统去分析这个intent,并帮我们找出合适的活动去启动，即可以相应这个隐式Intent的活动。</p>
<p>​    在activity标签下配置intent-filter的内容</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.activitytest.ACTION_START"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span> = <span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span>&gt;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">修改FirstActivity中按钮点击事件</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">                startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>​    每个Intent只能指定一个action，但却能指定多个category，目前我们只有一个默认的category</p>
<h2 id="2-3-3-MORE"><a href="#2-3-3-MORE" class="headerlink" title="2.3.3 MORE"></a>2.3.3 MORE</h2><p>​    使用隐式Intent，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使得android多个应用程序之间的功能共享成为了可能。</p>
<p>​    修改按钮点击如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">               intent.setData(Uri.parse(<span class="string">"http://www.baidu.com"</span>));</span><br><span class="line">               startActivity(intent);xxxxxxxxxx com.example.activitytest.MY_CATEGORY</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-3-4向下一个活动传递数据"><a href="#2-3-4向下一个活动传递数据" class="headerlink" title="2.3.4向下一个活动传递数据"></a>2.3.4向下一个活动传递数据</h2><p>​    Intent可以在启动活动的时候传递数据。</p>
<p>​    Intent中提供了一系列putExtra()方法的重载，可以将数据暂存intent中，启动后，下一个程序从中取出来，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">button3.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">              String data = <span class="string">"Hello thirdActivity"</span>;</span><br><span class="line">              Intent intent = <span class="keyword">new</span> Intent(SecondActivity.<span class="keyword">this</span>,ThirdActivity.class);</span><br><span class="line">              intent.putExtra(<span class="string">"extra_data"</span>,data);</span><br><span class="line">              startActivity(intent);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Intent intent = getIntent();</span><br><span class="line">      String data = intent.getStringExtra(<span class="string">"extra_data"</span>);</span><br><span class="line">      Log.d(<span class="string">"ThirdActivity"</span>,data);</span><br></pre></td></tr></table></figure>

<h2 id="2-3-5-返回数据给上一个活动"><a href="#2-3-5-返回数据给上一个活动" class="headerlink" title="2.3.5 返回数据给上一个活动"></a>2.3.5 返回数据给上一个活动</h2><p>​    通常返回数据只需要按下Back键，并没有一个用于启动活动Intent来传递数据，</p>
<p>​    activity中还有一个startActivityForResult()方法用于启动活动，但这个方法期望再活动销毁时能够返回一个结果给上一个活动。</p>
<p>​    startActivityForResult接受两个参数，第一个参数 Intent ，第二个请求码，用于再之后回调中判断数据的来源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Intent intent1 = <span class="keyword">new</span> Intent();</span><br><span class="line">                intent1.putExtra(<span class="string">"data_return"</span>,<span class="string">"i will calling"</span>);</span><br><span class="line">                setResult(RESULT_OK,intent1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (requestCode)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span>(resultCode ==RESULT_OK)&#123;</span><br><span class="line">                    String returnedData = data.getStringExtra(<span class="string">"data_return"</span>);</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>,returnedData,Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    如果用户选择Back键返回 重写onBackPressed()方法来解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-4活动的生命周期"><a href="#2-4活动的生命周期" class="headerlink" title="2.4活动的生命周期"></a>2.4活动的生命周期</h2><p>​    返回栈</p>
<p>​    Android是使用任务(task)来管理活动的，一个任务就是一组存放再栈里的活动的集合，这个栈也被称作返回栈，栈是一种后进先出的数据结构，再默认情况下，我们启动一个新的活动，它会在返回栈中入栈，并处于栈顶的位置，每当我们按下back 或者调用finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会重新处于栈顶的位置。系统 总是会显示处于栈顶的活动给用户。</p>
<p>​    活动状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节，下面来介绍这7个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onCreate() 这个方法中完成活动的初始化操作，比如加载布局，绑定事件</span><br><span class="line"></span><br><span class="line">onStart()  活动由不可见变为可见时调用</span><br><span class="line"></span><br><span class="line">onResume  活动准备好和用户进行交互时调用，此时的活动一定位于返回栈的栈顶，并且处于运行状态。</span><br><span class="line"></span><br><span class="line">onPause()  这个方法在系统准备去启动或者恢复另一个活动的时候调用，我们通常在这个方法中将一些资源释放，保留关键数据，但这个方法的执行要快。</span><br><span class="line"></span><br><span class="line">onStop()  这个方法活动完全不可见的时候调用，它和onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()方法并不会执行</span><br><span class="line"></span><br><span class="line">onDestroy() 这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</span><br><span class="line"></span><br><span class="line">onRestart() 这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。</span><br><span class="line"></span><br><span class="line">以上7个方法除了onRestart()方法，其他都是两两相对的，从而又可以将活动分为3种生存期。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">完整生存期:活动在onCreate()方法和onDestory()方法之间所经历的，就是完整生存期。一般情况下，一个活动会在onCreate()方法中完成释放内存的操作。</span><br><span class="line"></span><br><span class="line">可见生存期：活动在onStart()方法和onStop()方法之间所经历的，就是可见生存期。在可见生存期内，活动对于用户总是可见的，即便有可能无法和用户进行交互，我们可以通过这俩个办法，合理的管理那些对用户可见的资源，比如在onStart中对资源进行加载，在onstop中对资源进行释放，从而保证停止状态的活动不会占用过多内存。</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/安卓开发1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/安卓开发1/" class="post-title-link" itemprop="url">安卓开发1</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:40" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-3-4分析第一个Android程序"><a href="#1-3-4分析第一个Android程序" class="headerlink" title="1.3.4分析第一个Android程序"></a>1.3.4分析第一个Android程序</h2><p>​    .gradle和.idea： 防止android studio自动生成的文件。无需关心</p>
<p>​    .app  项目种的代码，资源等内容，几乎都是放置在这个目录下，后面的开发工作也基本是在这个目录下进行的。</p>
<p>​    .build 这个目录包含了编译时自动生成的文件，不用关心。</p>
<p>​    gradle 这个目录包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要将gradle提前下载好，自动下载。</p>
<p>​    .gitignore  用来将指定的目录或者文件排除在版本控制之外。</p>
<p>​    build.gradle 全局的gradle构建脚本， 通常不需要修改</p>
<p>​    gradle.properties 全局的gradle配置文件，配置的属性影响到项目中所有的gradle编译脚本</p>
<p>​    gradlew 和gradlew.bat 命令行界面中执行gradle命令，前者mac 后者windows</p>
<p>​    hello world.iml   iml文件是所有intellij idea项目都会自动生成的一个文件，用于标识这是一个idea项目</p>
<p>​    local.peoperties   用于指定本机中的android sdk的路径，通常自动生成，除非更该 需要手动设置。</p>
<p>​    settings.gradle 用于指定项目中所有引入的模块，由于hello world项目中只有一个app模块，因此该文件中也就只引入了app这一模块，通常情况下，模块的引入都是自动完成的。</p>
<hr>
<p>app目录</p>
<p>​    build 自动生成，</p>
<p>​    libs  如果使用了第三方的jar包，那么需要把这些jar包放在libs目录下，jar包会自动添加到构建路径</p>
<p>​    Androidtest 用来便携Android test测试用例，可以对项目进行一些自动化测试。</p>
<p>​    java  该目录放置所有java代码</p>
<p>​    res   项目中使用到的所有图片，布局，字符串等等资源都要放在这个目录下，drawable 图片，layout 布局</p>
<p>​    AndroidMainfest.xml   这是整个android项目的配置文件，在程序中定义的所有四大组件都需要在这个文件里注册，另外还可以在这个文件中给应用程序添加权限声明。</p>
<p>​    test   编写unit test测试用例，是对项目进行自动化测试的另一种方式</p>
<p>​    .gitignore 类似外层</p>
<p>​    app.iml  </p>
<p>​    build.gradle app模块的gradle构建脚本，这个文件中会指定很多项目构建相关的配置</p>
<p>​    progurad-rules.pro  指定项目代码的混淆规则</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">".HelloWorldActivity"</span>&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;category android:name=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">        </span><br><span class="line">                   </span><br><span class="line">这段代码表示对HelloWorldActivity这个活动进行注册，没有在AndroidManifest.xml里注册的活动是不能使用的。</span><br><span class="line">	其中intent-filter中的两行代码，表示helloworldactivity是这个项目的主活动，当在手机桑点击应用图标，首先启动的就是这个活动。</span><br><span class="line">	活动是android应用程序的门面，凡是在应用中你看得到的东西。都是放在活动中的，因此你在app中看到的界面，其实就是这个活动。</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.hello_world_layout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hellowWorldActivity是继承自appcompatactivity的，这是一种向下兼容的activity，可以将activity在各个系统版本中增加的特性和功能兼容到Android2.1系统。</span><br><span class="line">	我们项目中所有的活动都必须继承它或者它的子类。比如此处appcompatactivity。</span><br><span class="line">	oncreate方法，这个方法是活动被创建必须要执行的方法。</span><br><span class="line">	我们在布局文件中写入界面，在活动中引入layout布局。</span><br><span class="line">	</span><br><span class="line">	打开res/layout目录下的 hello_world_layout.xml文件，切换到text视图</span><br></pre></td></tr></table></figure>

<h2 id="1-3-6-详解build-gradle文件"><a href="#1-3-6-详解build-gradle文件" class="headerlink" title="1.3.6 详解build.gradle文件"></a>1.3.6 详解build.gradle文件</h2><p>外层+ 内层</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.2.0'</span></span><br><span class="line">    <span class="comment">//Gradle并不是专门为了构建Android项目而开发的。 java，c++等项目都可以使用Gradle来构建，因此</span></span><br><span class="line">        <span class="comment">//如果需要用gradle，则需要声明插件，后面是版本号。</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()<span class="comment">//jcenter是代码托管仓库，声明这个配置，我们可以轻松引用任何jcenter</span></span><br><span class="line">                <span class="comment">//上的开源项目。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">clean</span><span class="params">(type: Delete)</span> </span>&#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'com.android.application'</span>  <span class="comment">//声明，应用程序模块</span></span><br><span class="line">                                        <span class="comment">//除此之外还有库模块。</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">24</span>   <span class="comment">//指定项目的编译版本 24 android7.0</span></span><br><span class="line">    buildToolsVersion <span class="string">"28.0.3"</span><span class="comment">//构建工具的版本</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.example.a76639.helloworld"</span> <span class="comment">//指定项目的包名</span></span><br><span class="line">        minSdkVersion <span class="number">15</span><span class="comment">// 指定项目最低兼容的android系统版本 15为4.0</span></span><br><span class="line">        targetSdkVersion <span class="number">24</span><span class="comment">//表示你已经在该目标版本上做了充分的测试，系统启用新的功能和特性</span></span><br><span class="line">        versionCode <span class="number">1</span>  <span class="comment">//版本号</span></span><br><span class="line">        versionName <span class="string">"1.0"</span><span class="comment">//版本名</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">false</span>  <span class="comment">//是否进行混淆</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">dependencies </span>&#123;<span class="comment">//指定当前项目的所有依赖关系</span></span><br><span class="line">    <span class="function">compile <span class="title">fileTree</span><span class="params">(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span></span></span><br><span class="line"><span class="function">    <span class="title">androidTestCompile</span><span class="params">(<span class="string">'com.android.support.test.espresso:espresso-core:2.2.2'</span>, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        exclude group: <span class="string">'com.android.support'</span>, <span class="keyword">module</span>: <span class="string">'support-annotations'</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span></span><br><span class="line"><span class="function">    compile 'com.android.support:appcompat-v7:24.2.1'</span></span><br><span class="line"><span class="function">    testCompile 'junit:junit:4.12'</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="comment">//本地依赖，远程依赖，库依赖</span></span></span><br></pre></td></tr></table></figure>

<h2 id="关于日志工具"><a href="#关于日志工具" class="headerlink" title="关于日志工具"></a>关于日志工具</h2><p>log.v   verbose琐碎</p>
<p>log.d   debug  调试</p>
<p>log.i  info   帮助分析用户行为数据，  </p>
<p>log.w  warn  警告信息。</p>
<p>log.e  erro   </p>
<p>onCreate方法外  logt +tab 生成tag</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/IP网络互联机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/IP网络互联机制/" class="post-title-link" itemprop="url">IP网络互联机制</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:25" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="IP网络互联机制"><a href="#IP网络互联机制" class="headerlink" title="IP网络互联机制"></a>IP网络互联机制</h2><p>​    网络互联的关键是IP，IP核心内容是IP地址和IP分组</p>
<p>​    节点根据IP分组目的IP地址和路由表确定下一跳的IP地址</p>
<p>​    由传输网络实现IP分组从当前跳到下一跳的传输过程</p>
<p>​    IP分组经过不同的传输网络传输时，需封装成传输网络对应帧格式</p>
<p>​    </p>
<h2 id="IP分类编制"><a href="#IP分类编制" class="headerlink" title="IP分类编制"></a>IP分类编制</h2><p>IP地址分类方法</p>
<p>IPV4 32位  IPV6 128位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">分层编制：网络号+主机号</span><br><span class="line">	如何确定网络号和主机号的位数?</span><br><span class="line">A类地址：0+网络号+主机号（1+3）</span><br><span class="line">B类地址  10+网络号+主机号（2+2）</span><br><span class="line">C类地址 110+网络号加主机号（3+1）</span><br><span class="line">D类地址 1110+组播地址</span><br><span class="line">E类地址 11110+保留</span><br></pre></td></tr></table></figure>

<p>$$<br>\left{<br>\begin{aligned}<br>单播地址A,B,C分层，包括网络号和主机号两个部分\<br>主机号全0表示网络地址，比如192.1.1.0是一个C类地址，低8位全0\<br>主教号全1为直接广播地址<br>32位全为1表示受限广播地址，限于发送端所在网络<br>\end{aligned}<br>\right.<br>$$</p>
<p>A类地址中，0.0.0.0表示IP地址无法确定的那个，终端没有分配IP地址前，可以作为IP分组的源地址。</p>
<p>127.x.x.x是回送测试地址</p>
<p><strong>著名组播地址</strong>：</p>
<p>​    224.0.0.1：表示网络中所有支持组播的终端和路由器</p>
<p>​    224.0.0.2：表示网络中所有支持组播的路由器</p>
<p>​    224.0.0.9：表示网络中所有运行RIP进程的路由器</p>
<p>IP地址分类分层的原因</p>
<p>​    IP地址为什么分类？网络规模不同</p>
<p>​    每一个组织的终端是不同的，根据终端数量选择IP地址类型</p>
<p>​    1.根据终端IP地址确定终端连接的网络</p>
<ol start="2">
<li><p>减少路由项的需要？？？</p>
<p>一：网络地址表示一组终端的IP地址；二：通往这一组终端的下一跳路由器相同</p>
</li>
</ol>
<p><strong>IP地址配置原则</strong></p>
<p> 1.每个传输网络都有一个网络地址</p>
<p>2.连接在同一个传输网络上的终端都必须配置具有相同网络号，不同主机的IP地址</p>
<p>3.路由器的每一个接口都需配置IP地址，该IP地址对应的网络地址必须和分配给该接口连接的传输网络的网络地址相同。</p>
<p><strong>IP地址不是终端或者路由器的标识符，而是终端或路由器接口的标识符</strong></p>
<p><strong>接口是指终端或路由器与网络之间的连接点，终端或路由器允许由多个接口</strong></p>
<p><strong>每一个接口都有独立的标识符–IP地址</strong></p>
<p><strong>IP地址特点</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每一个IP地址都由网络号和主机号两部分组成，IP地址是一种分等级的地址结构，分两个等级的好处是：第一：IP地址管理机构在分配IP地址时只分配网络号，而剩下的主机号由得到该网络号的单位来自行分配。第二：路由器仅根据目的主机所连接的网络号来转发分组，这样就可以使得路由表中的项目大幅度减少，从而减少了路由表所占额存储空间以及查找路由表的时间。</span><br><span class="line">IP地址是标志一台主机（或者路由器）和一条链路的接口， 当一台主机同时连接到网络上时，该主机就必须同时具有两个相应的IP地址，其网络号必须是不同的，这种主机交多归属主机。</span><br><span class="line">按照互联网的观点，一个网络是指具有相同网络号的主机的集合，因此用转发器或网桥连接起来的若干个局域网仍然为一个网络，因为这些局域网都具有同样的网络号，具有不同网络号的局域网必须使用路由器进行互连。</span><br><span class="line">在IP地址中，所有分配到网络号的网络，都是平等的，互联网同等对待每一个IP地址。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IP地址与硬件地址</span><br><span class="line">	物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和以上各层使用的地址，是一种逻辑地址。在发送数据时，数据从高层下到底层，然后才到通信链路上传输，使用IP地址的IP数据包一旦交给了数据链路层，就被封装成了MAC帧，MAC帧在传送时使用的源地址和目的地址都是硬件地址。网络层和网络层以上使用的IP地址，数据链路层以下使用的硬件地址。</span><br><span class="line">	</span><br><span class="line">1.IP层抽象的互联网上只能看到IP数据报。</span><br><span class="line">2.路由器只根据目的站的IP地址的网络号进行路由选择。</span><br><span class="line">3.在局域网的链路层，只能看见MAC帧</span><br><span class="line">4.尽管互联在一起的网络的硬件地址体系各不相同，但是IP层的抽象的互联网却屏蔽了下层这些很复杂的细节，只要我们在网络层上讨论问题，就能够使用同一的，抽象的IP地址研究主机和主机或路由器之间的通信。</span><br></pre></td></tr></table></figure>

<p><strong><em>IP地址分类的缺陷</em></strong></p>
<p>1.浪费严重</p>
<p>​    单播IP地址分为A,B,C三类，每一类IP地址有着固定位数的网络号和主机号。</p>
<p>2.不能更有效的减少路由项：</p>
<p>​    假设192.1.4.0 和192.1.5.0，都在接着R2   R1 接R2 ，下一跳地址一样，却要重复存储，这一组IP地址的高23位是一样的，但是对于路由器R2来说，这俩个网络可以用同一项路由，但是没有主机号为9位的IP地址类型。</p>
<p>3.C类地址利用率低</p>
<p>​    C类IP地址中网络号的位数是21位，使得C类地址网络地址数量最多，大部分网络所连接的终端大于2^8^ -2个，使得真正申请C类地址的单位很少。</p>
<h2 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h2><p>1.从两级IP地址到三级IP地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.IP地址空间的利用率很低，</span><br><span class="line">	每一个A类地址网络可连接主机数超过1000W，B超过6W，有的单位申请B，却用不完，不愿意申请C，浪费</span><br><span class="line">2. 给每一个物理网络分配一个网络号会使得路由表变大而使得网络性能变坏。</span><br><span class="line">	互联网中网络越多，路由器的路由表项目也越多，增加了路由器成本，查找时间更多，路由器之间定期交换的路由信息急剧增加，互联网性能下降。</span><br><span class="line">3.两级IP地址不够灵活</span><br><span class="line">	一个单位弄了新的网络，如果没有申请到新的IP地址，是没法投入工作的，希望有新的办法，使得能灵活增加新的网络，不必取申请新的网络号。</span><br></pre></td></tr></table></figure>

<p>为了解决上述问题，在1985年，IP地址中增加了一个 子网号字段，使得两级IP地址变为三级IP地址，能够较好的解决上述问题。这种做法叫做划分子网，或子网寻址或<strong>子网路由选择</strong>。划分子网的基本思路如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">一个拥有许多物理网络的单位，可将所属物理网络划分为若干个子网，划分子网属于一个单位内部的事情。本单位以外的网络看不见这个网络是由多少个子网组成，因为这个单位对外仍然表现为一个网络。</span><br><span class="line"></span><br><span class="line">划分子网的方法是从网络的主机号中借用若干位作为子网号，当然主机号也就相应减少了同样的位数，于是两级IP地址在本单位内部就变成了三级IP地址：网络号，子网号, 主机号</span><br><span class="line"></span><br><span class="line">凡是从其他网络发送给本单位某台主机的IP数据报，仍然是根据IP数据报的目的网络号找到连接在本单位网络上的路由器，当此路由器收到IP数据报后，再按目的网络号和子网号找到目的子网，把IP数据包交付给目的主机。</span><br><span class="line"></span><br><span class="line">*******************************************</span><br><span class="line">接下来的问题是，假定由一个数据报已经到达了路由器R1，那么这个路由器如何把它转发到子网145.13.3.0？</span><br><span class="line"></span><br><span class="line">子网掩码：</span><br><span class="line">从IP报的首部无法看出源主机或者目的主机是否进行了子网划分，这是因为32位IP地址以及数据报的首部没有任何包含子网划分的信息</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">从网络 145.13.0.0外面看，这是一个普通的B类网络，其子网掩码为16个1+16个0。但是进入到这个网络后，就看到了还有许多网络(即划分了子网后的许多网络)，其网络地址为145.13.x.0而这些网络的子网掩码都是24个1+8个0，总之这个B类网络的外卖和里面，看到的网络不一样。</span><br><span class="line"></span><br><span class="line">再不划分子网时，既然没有子网， 为什么还要使用子网掩码？这是为了更好的查找路由表。</span><br><span class="line">现代互联网规定：所有的网络都必须使用子网掩码，同时再路由器的路由表中也必须由子网掩码这一栏，如果一个网络不划分子网，那么该网络的子网掩码就是默认的子网掩码，默认子网掩码中1的位置和IP地址中的网络号相对应。</span><br><span class="line"> 比如A类子网掩码 255.0.0.0</span><br><span class="line"> </span><br><span class="line"> 子网掩码是一个网络或者子网的重要属性，再RFC 950成为互联网的正式标准后，路由器在和相邻路由器交换路由信息时，必须把自己所在网络的子网掩码告诉相邻的路由器，在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码</span><br><span class="line"> 如果一个路由器连接在两个子网上，就由两个网络地址和两个子网掩码。</span><br><span class="line"> </span><br><span class="line"> RFC 950文档，子网号不能全1or全0</span><br><span class="line"> </span><br><span class="line"> 划分子网增加了灵活性，但却减少了能够连接在网络上的子网总数</span><br></pre></td></tr></table></figure>

<p>使用子网时分组的转发</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.从收到的数据报的首部提取目的Ip地址 D</span><br><span class="line">2.先判断是否为直接交付： 对路由器直接相连的网络进行逐个检查：用各网络的子网掩码和D 与操作，看结果是否和相应的网络地址像匹配，如果匹配的话，则把分组直接交付，（需要把D转为物理地址，数据报封装成帧发送出去）。 否则 执行(3)</span><br><span class="line">3.如果路由表中由目的地址为D的特定主机的路由，则把数据报传送给路由表中所指明的吓一跳路由器 否则执行4</span><br><span class="line">4. 对路由器中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和D 与操作， 其结果为N ，如果N与该行目的地址匹配，则把数据报传给下一跳路由器 否则 5</span><br><span class="line">5. 若路由表中由一个默认路由，则传给默认路由，否则 6</span><br><span class="line">6.wrong X-X</span><br></pre></td></tr></table></figure>

<h2 id="IP-无分类编制-构造超网"><a href="#IP-无分类编制-构造超网" class="headerlink" title="IP -无分类编制(构造超网)"></a>IP -无分类编制(构造超网)</h2><p>划分子网在一定程度上解决了互联网在发展中遇到的困难，1992年互联网仍然面临三个必须解决的问题：</p>
<ol>
<li><p>B 类地址在1992年以及分配了近一半，很快全部分配完毕</p>
</li>
<li><p>互联网主干网络上的路由表中的项目急剧增长，从几千个增长到几万个</p>
</li>
<li><p>整个IPV地址空间最终全部耗尽，，2011年，IANA宣布，IPV4地址以及耗尽了。</p>
<p>当时预计前两个问题将在1994年变得非常严重，因此IETF很快就研究出采用五分类编址的方法来解决前两个问题，IETF认为第三个问题属于更加长远的问题，因此专门成立了IPv6工作组专门解决研发新版本IP协议的问题。</p>
</li>
</ol>
<p>无分类域间路由选择 Classless Inter-Domain Routing， CIDR的读音是“sider” </p>
<p>==特点==</p>
<p>CIDR消除了传统的A类，B类，C类地址和划分子网的概念，并且在新的IPv6地址使用之前容许互联网的规模继续增长，CIDR把32位IP分为前后两个部分，前面部分是==网络前缀==，用来指明网络，后面部分用来指明主机，所以CIDR从三级编址又变成了两级编址</p>
<p>​                {&lt;网络前缀&gt;&lt;主机号&gt;}</p>
<p>CIDR还用==斜线计法==，即在IP地址后面加上/ 标识网络前缀的位数</p>
<p>CIDR 把网络前缀都相同的连续的IP地址组成一个 CIDR地址块，我们只要直到CIDR地址块中央的任何一个地址，就可以直到这个地址块的起始地址和最大地址，以及地址数，example as following;</p>
<p>​            128.14.35.7/20</p>
<p>​            128.14.32.0</p>
<p>​            128.14.47.255 </p>
<p>​            以上这两个特殊地址的主机号是全0和全1，一般不使用，通常只用在这俩个特殊地址之间的地址。</p>
<p>​            为了更方便地进行路由选择，CIDR使用 32位地址掩码，地址掩码由一串1和一串0组成，而1的个数就是网络前缀的长度，虽然CIDR不使用子网了，但由于目前仍然有一些网络还使用子网划分和子网掩码，因此CIDR使用的地址掩码也可以继续成为子网掩码</p>
<p>​    ==“CIDR不使用子网”==是指CIDR并没有在32位地址中指明若干位位子网字段，但分配到一个CIDR地址块的单位，仍然可以在本单位内根据需要划分子网，这些子网也都只有一个网络前缀和一台主机号字段，但是子网的网络前缀比整个单位的网络前缀要长一些。</p>
<p>​        斜线记法还有一个好处就是它除了标识一个IP地址外，还提供了其他的一些重要信息。</p>
<p>​        由于一个CIDR地址块中有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络，这种地址的聚合常常成为路由聚合，它使得路由表中的一个项目可以表示原来传统分类地址的很多个路由。</p>
<h2 id="IP分组格式"><a href="#IP分组格式" class="headerlink" title="IP分组格式"></a>IP分组格式</h2><p>——4——————8————————16———19———————31</p>
<p>版本  | 首部长度            |服务类型                          |            总     长       度                    |</p>
<p>​                 标                                            识                 |    标  志   |               片偏移           |</p>
<p>生       存      时   间         |  协                             议   |首            部        校        验        和 |</p>
<p>​                                                源                        地                        址</p>
<p>​                                    目                    的                    地                    址</p>
<p>​                            可                    选            字                        段(长度可变)</p>
<p><strong>前五行固定部分20字节</strong> 4*8 = 20</p>
<p>下面分别介绍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">版本：</span><br><span class="line">	占4位， 指IP协议的版本。通信双方是使用的IP协议的版本必须一致，目前广泛使用的IP版本号为4</span><br><span class="line">首部长度：</span><br><span class="line">	4位，可表示最大十进制数是15，首部长度字段所表示数的单位是32位字，因为IP首部固定长度为最大值1111时，就表明首部长度达到15个32位字长，即60个字节。  当 IP分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充，因此IP数据包的数据部分永远在4字节的整数倍时开始，首部长度限制位60字节的缺点是有时候不够用，这样希望用户尽量减少开销，最常用的首部长度是20字节，这时不使用任何选项。</span><br><span class="line">区分服务：</span><br><span class="line">	占8位，用来获得更好的服务，这个字段在旧标准中叫做服务类型。实际上一直没有被使用过，1998那年IETF把这个字段改为了 Differentiated Services 区分服务。只有在使用区分服务时候，才使用这个字段。</span><br><span class="line">总长度：</span><br><span class="line">	指的是首部和数据之和的长度，单位为字节。2^16-1 为最大字节。</span><br><span class="line">实际上这样长的数据报很少遇到。如果IP数据报超过了数据链数层最大长度，必须分片处理 比如以太网最大帧长度1500字节</span><br><span class="line">标识：</span><br><span class="line">	占16位，IP软件在存储器中维持着一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段，但这个标识并不是序号，因为IP是无连接服务，数据报并不存在按序接受的问题，当数据报由于长度超过mtu而必须分片时，这个标识字段就被复制到所有的数据报片的标识字段中，相同的标识字段的值使分片后各数据报片最后能正确地重装为原来的数据报。</span><br><span class="line">标志：</span><br><span class="line">	占3位。目前只有前两位有意义，标志字段中的最低位记为MF，MF等于1标识后面还有分片数据，==0标识这是最后一个。</span><br><span class="line">	中间位DF，表示不能分片，  ==0  允许分片</span><br><span class="line">片偏移：</span><br><span class="line">	占13位，片偏移指出，较长的分组在分片后，某片在原分组中的相对位置，也就是说，相对于用户数据字段的起点，该片从何处开始，片偏移以8个字节为偏移单位，这就是说，每个分片的长度一定是8字节的整数倍。</span><br><span class="line"></span><br><span class="line">生存时间：</span><br><span class="line">	占8位，生存时间字段常用的英文缩写TTL  time to live， 表明这是数据报在网络中的寿命，设计之初采用的是s为单位，现在 改为了跳数限制，防止无法交付的数据报无限制在网络中兜圈子，浪费网络资源，TTL的意义是指明数据报在互联网中至多可以经过多少个路由器，显然，数据报能在互联网中经过的路由器的最大值255，如果把TLL初始值置为1，说明该数据报只在本局域网中传送。</span><br><span class="line"></span><br><span class="line">协议：</span><br><span class="line">	占8位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个协议处理。</span><br><span class="line">首部校验和：</span><br><span class="line">	占16位，这个字段只检测数据报的首部，但不包括数据部分，这是因为数据报每经过一个路由器，路由器都要重新计算一次首部校验和，不检测数据部分减少了计算的工作量。</span><br><span class="line">	IP首部的检验和不采用复杂的CRC检测码，而采用下面的简单计算方法：在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置0，用反码算术运算把所有16位字相加，将得到的和的反码写入检验和字段，接收方收到数据后，</span><br></pre></td></tr></table></figure>

<p># </p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/ICMP协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/ICMP协议/" class="post-title-link" itemprop="url">ICMP协议</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:07" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ICMP报文</p>
<p>这是internet的控制协议</p>
<p>功能如下：</p>
<ol>
<li>检测internet的操作</li>
<li>报告IP分组传输过程中发生的意外情况</li>
<li>测试Internet的运行状况</li>
</ol>
<p>分为两类：</p>
<p>​        1.差错报告报文：向ip分组的发送终端发送不同类型的差错报告报文分为如下：</p>
<p>​                    1.终点不可达：网络不可达；主机不可达；协议不可达；端口不可达；需要分片但是DF位置1；源路由失败。</p>
<p>​                    2.源站抑制：当路由器或者是主机因为拥塞二丢弃ip分组时，就要像ip分组发送端发送源站一直报文，要求ip分组发送终端降低发送的速率。</p>
<p>​                    3.超时：路由器收到了生存时间为0的ip分组，接受终端在规定时间内不能接受到分片某个ip分组后产生的全部数据片。</p>
<p>​                    4.参数问题：路由器或者目的终端接收到首部由错的ip分组，且已经无法再继续转发该ip分组</p>
<p>​                    5.改变路由：A-b  b-c 但是通过b的同一个接口</p>
<p>​                    </p>
<ol start="2">
<li><p>询问报文：</p>
<p>​        1.路由器或主机通过回送请求报文向一个特定的设备发出询问，接收到该报文的设备必须向发送回送请i去报文的源设备回答一个回送响应报文。</p>
<p>​        2.时间戳请求和响应： 时间戳请求报文用于向某个目的设备询问当前的日期和时间; 时间戳响应报文用于回送接收请求报文的日期和时间及发送响应报文的日期和时间。</p>
<p>​        3.地址掩码和响应：主机通过子网掩码请求和响应来获知所在的网络的子网掩码。</p>
<p>​        4.路由器询问和通告：主机通告广播路由器询问报文  查询网络内路由器的工作状态，  收到路由器询问报文的路由器通过广播路由器通告报文来通告器路由信息。</p>
</li>
</ol>
<pre><code>ICMP应用

ping命令：判断两个终端之间是否连通

tracert命令：两终端之间通过的路由器的ip地址。</code></pre>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/熵及熵编码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/熵及熵编码/" class="post-title-link" itemprop="url">熵编码</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:49" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="2-1熵及熵编码原理"><a href="#2-1熵及熵编码原理" class="headerlink" title="2.1熵及熵编码原理"></a>2.1熵及熵编码原理</h1><p>##　2.2.1信息量的概念</p>
<p>信息量：表示该符号所需要的位数<br>    ｀考虑用０和１组成的二进制数码<br>    ｀为含有ｎ个符号的某条消息编码<br>    ｀假设符号$a_j$在整条消息中重复出现的概率为$P_j$,则该符号的信息量定义为</p>
<p>​                                  $E_n = - log_2(P_j)$ </p>
<p>​    ｀信息量表示为以２为底的对数，是正值</p>
<p>举例说明:<br>输入信源字符串: aabbaccbaa<br>a、b、c 出现的概率分别为 0.5、0.3和 0.2,他们的信息量分别为:<br>Ea = -log 2 (0.5) = 1<br>Eb = -log 2 (0.3) = 1.737<br>Ec = -log 2 (0.2) = 2.322<br><strong>总信息量也即表达整个字符串需要的位数</strong>:<br>E = Ea * 5 + Eb * 3 + Ec * 2 = 14.855 位</p>
<p>输入信源字符串：aabbaccbaa</p>
<p>解：　字符串有３个不同的字符，又因为２位二进制数能表示４个不同的字符，</p>
<p>所以对每个字符用２位二进制数表示，例如</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>ａ</th>
<th>ｂ</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>等长编码</td>
<td>００</td>
<td>０１</td>
<td>１０</td>
</tr>
</tbody></table>
<p>那么，这１０个字符就需要２０位二进制数表示。</p>
<h2 id="2-2-2熵编码的概念"><a href="#2-2-2熵编码的概念" class="headerlink" title="2.2.2熵编码的概念"></a>2.2.2熵编码的概念</h2><p>｀数据压缩的基石——Shannon于１９４８年创立的信息论</p>
<p>｀Shannon第一定律(率失真定律)　确定了在编码过程中不损失任何信息，即在无损编码条件下数据压缩的理论极限是信息的熵，并指出了如何建立最优数据压缩编码方法。</p>
<p>｀这类保存信息熵的编码方法统称为<strong>熵编码</strong>(Entropy coding)</p>
<p>｀信源符号集合　$A({a_1,a_2,a_3,….,a_j})$  其中每个元素$a_j$为信源符号。</p>
<p>｀设信源产生符号$a_j$ 这个时间的概率是$P_j$ ,则对每个信源输出的平均信息为</p>
<p>​                         $H(x) = - \sum_{j=1}^{m}P_j*log_2p_j$</p>
<p>​                          $\sum_{j=1}^mP_j=1$</p>
<p>信息源的平均信息量称为Ｅｎｔｒｏｐｙ　“熵”</p>
<h2 id="2-2-3平均码长概念"><a href="#2-2-3平均码长概念" class="headerlink" title="2.2.3平均码长概念"></a>2.2.3平均码长概念</h2><p>`如果对字符$a_j$的编码长度$L_j$，则信号Ｌ的平均码长为：</p>
<p>　　　　　　　　$L_{avg} = \sum_{j=1}^mp_j*L_j​$</p>
<h2 id="2-2-4无失真编码概念"><a href="#2-2-4无失真编码概念" class="headerlink" title="2.2.4无失真编码概念"></a>2.2.4无失真编码概念</h2><p>　　　　　　　　｀平均码长$L_{avg}&gt;&gt;H(X)$有冗余，不是最佳</p>
<p>　　　　　　　　｀平均码长$L_{avg}&lt;H(X)$　不可能</p>
<p>　　　　　　　　｀平均码长$L_{avg}≈H(X)$　　最佳编码</p>
<p>​                    熵值是平均码长的下限。</p>
<p>最常用－－－－Ｈｕｆｆｍａｎ编码</p>
<h2 id="2-2-5编码效率的定义"><a href="#2-2-5编码效率的定义" class="headerlink" title="2.2.5编码效率的定义"></a>2.2.5编码效率的定义</h2><p>｀熵Ｈ(ｘ)除以平均码长$L_{avg}$ 即表示编码效率</p>
<p>｀$H(x) = -\sum_{j=1}^mP_j*log_2p_j$</p>
<p>$\eta=\frac{H(x)}{L_{avg}}$   $\eta &lt;= 1 $</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据压缩的理论极限是信息熵</span><br><span class="line">	只要信源不是等概率分布，那么就存在着数据压缩的可能性</span><br><span class="line">数据压缩的基本途径之一：　使各个字符的　　编码长度尽量等于字符的信息量</span><br></pre></td></tr></table></figure>

<h1 id="2-2Huffman编码"><a href="#2-2Huffman编码" class="headerlink" title="2.2Huffman编码"></a>2.2Huffman编码</h1><h2 id="2-2-1Huffman算法简介"><a href="#2-2-1Huffman算法简介" class="headerlink" title="2.2.1Huffman算法简介"></a>2.2.1Huffman算法简介</h2><p>｀哈弗曼编码是１９５２年为压缩文本文件所设计的编码方法，也是目前消除视频信息冗余最常使用的方法之一</p>
<p>｀对出现<strong>概率最大</strong>的符号附以<strong>最短的码字</strong>，概率越小表示的码字越长，从而使表示每个符号的平均比特数最小。</p>
<h2 id="2-2-2Huffman编码步骤"><a href="#2-2-2Huffman编码步骤" class="headerlink" title="2.2.2Huffman编码步骤"></a>2.2.2Huffman编码步骤</h2><p>1.把信源符号按概率大小顺序排列　－(概率排列)</p>
<p>2.在分配码字长度时，首先将两个出现概率最小的两个符号的概率相加，合成一个概率－合并</p>
<p>3.把合成概率看作是一个新组合符号的概率，重复上述做法，直到最后只剩下两个符号的概率为止；　－(置换)</p>
<p>4.完成上述步骤后，再返回向前进行编码，每层有两个分枝，分别赋予０和１。大的赋0或小的 赋0均可，但必须 一致。</p>
<h2 id="2-2-3Huffman编码特点"><a href="#2-2-3Huffman编码特点" class="headerlink" title="2.2.3Huffman编码特点"></a>2.2.3Huffman编码特点</h2><p>｀霍夫曼编码是瞬时唯一的可解块编码；</p>
<p>​    ｀<strong>瞬时</strong>：符号串中每个码字无需参考后继符号就可以解码</p>
<p>​    ｀<strong>唯一可解码</strong>：任何符号串只能以一种方式解码</p>
<p>　　｀<strong>块编码</strong>：每个信源符号都映射到一个编码符号的固定序列中；</p>
<p>｀霍夫曼编码是唯一可译码，短的码不会成为更长码的起始部分；</p>
<p>｀霍夫曼编码的平均码长接近于熵</p>
<p>｀与计算机的数据结构不匹配</p>
<p>｀需要多次排序，耗费时间</p>
<p>｀霍夫曼编码的局限性在于：<strong>该编码方法只适用于离散信号源，即信源符号个数为有限数</strong></p>
<p>`编码时，需要知道输入符号集的概率分布</p>
<p>`在进行Huffman编码压缩时，计算量大且复杂，尤其是译码复杂度高</p>
<p>`由于码长不等，存在一个输入输出速率匹配问题。</p>
<h2 id="2-2-4Huffman编码举例"><a href="#2-2-4Huffman编码举例" class="headerlink" title="2.2.4Huffman编码举例"></a>2.2.4Huffman编码举例</h2><p>​    <strong>例1</strong>：设有一幅图8x8图像，其灰度级分布见下图所示，对其进行HUffman编码，给出编码过程和码字，并计算平均码字长，信息熵，编码效率和压缩比。</p>
<p>$$<br>f(m,n)=\left[<br>\begin{matrix}<br>3&amp;3&amp;3&amp;3&amp;3&amp;3&amp;3&amp;1\<br>3&amp;3&amp;3&amp;3&amp;3&amp;3&amp;3&amp;1\<br>3&amp;4&amp;4&amp;4&amp;4&amp;4&amp;3&amp;1\<br>3 &amp;4&amp; 2&amp; 5&amp; 2&amp; 4&amp; 3&amp; 1\<br>3 &amp;4&amp; 5&amp; 5&amp; 5&amp; 4&amp; 3 &amp;1\<br>3 &amp;4 &amp;4 &amp;4 &amp;4 &amp;4 &amp;3 &amp;1\<br>3 &amp;3&amp; 3&amp; 3&amp; 3&amp;3 &amp;3 &amp;1<br>\end{matrix}<br>\right]<br>$$<br>解：计算每个灰度级出现的概率</p>
<p>P(1)=8/64， P(2)=2/64， P(3)=31/64， P(4)=16/64， P(5)=7/64， </p>
<table>
<thead>
<tr>
<th>初始信源符号</th>
<th>概率</th>
<th>信源编码过程</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>31/64 =1</td>
<td>31/64 =1       31/64 =1       33/64 =0</td>
</tr>
<tr>
<td>4</td>
<td>16/64 = 01</td>
<td>16/64  =01      17/64 = 00       31/64 =1</td>
</tr>
<tr>
<td>1</td>
<td>8/64 =001</td>
<td>9/64  =000        16/64 =01</td>
</tr>
<tr>
<td>5</td>
<td>7/64 =0000</td>
<td>8/64  =001</td>
</tr>
<tr>
<td>2</td>
<td>2/64 =0001</td>
<td></td>
</tr>
</tbody></table>
<p>`获得的码字见下表：</p>
<table>
<thead>
<tr>
<th>灰度级(i)</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>概率P(i)</td>
<td>8/64</td>
<td>2/64</td>
<td>31/64</td>
<td>16/64</td>
<td>7/64</td>
</tr>
<tr>
<td>码字(M)</td>
<td>001</td>
<td>0001</td>
<td>1</td>
<td>01</td>
<td>0000</td>
</tr>
<tr>
<td>码字长度(L(i))</td>
<td>3</td>
<td>4</td>
<td>1</td>
<td>2</td>
<td>4</td>
</tr>
</tbody></table>
<p>`平均码字长度如下</p>
<p>$L_{avg} = \sum_{i=1}^5P(i)L(i) = (8/64)<em>3+(2/64)</em>4+(31/64)<em>1+(16/64)</em>2\+(7/64)*4=1.921875$</p>
<p>`信息熵</p>
<p>​    $H(f) = -\sum_{i=1}^5P(i)log_2P(i)$=1.887</p>
<p>`<strong>编码效率</strong></p>
<p>$\eta=\frac{H}{L_avg} = \frac{1.887}{1.921875} = 0.9819$</p>
<p>`<strong>压缩比</strong></p>
<p>$C_R = \frac{m}{L_{avg}} = \frac{3}{1.921875} = 1.56$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">霍夫曼编码的局限性</span><br><span class="line">	`可变编码，译码复杂</span><br><span class="line">	`需要事先知道输入符号集的概率分布</span><br><span class="line">	`没有错误保护功能</span><br></pre></td></tr></table></figure>

<h1 id="2-3算术编码"><a href="#2-3算术编码" class="headerlink" title="2.3算术编码"></a>2.3算术编码</h1><h2 id="2-3-1算术编码原理"><a href="#2-3-1算术编码原理" class="headerlink" title="2.3.1算术编码原理"></a>2.3.1算术编码原理</h2><p>`算术编码是1980年代发展起来的熵编码方法</p>
<p>`基本原理是将被编码的数据序列表示成0和1之间的一个间隔（一个小数范围），该间隔的位置与输入数据概率分布有关，信息越长，编码表示的间隔就越小，因而表示这一间隔所需的二进制位数就越多(由于间隔是用小数表示的)。</p>
<h2 id="2-3-1算术编码步骤"><a href="#2-3-1算术编码步骤" class="headerlink" title="2.3.1算术编码步骤"></a>2.3.1算术编码步骤</h2><p>`算术编码是从整个符号序列出发，采用递推式的连续编码的方法。</p>
<p>`解码时，根据该区间判断信源各个符号出现的顺序和类型</p>
<p><strong>举例</strong></p>
<p>设信源符号表{$a_1,a_2,a_3,a_4$},其符号出现的概率分别为{$0.2,0.1,0.4,0.3$},请按照序列{$a_2,a_1,a_4,a_3$}进行算术编码。</p>
<p><strong>解</strong>：</p>
<p><strong>(1)首先定义算法空间[0 1 ].</strong></p>
<p><strong>(2)确定各个字符的区间分配，建立码点。</strong></p>
<p><strong>码点满足如下两条规则</strong></p>
<p>(a)每一个码点值是它前面所出现的概率之和；</p>
<p>​    每一个码点值是0，因为它之前没有码字；第一个符号a1出现的概率为0.2，故第二个码点的值是0.2，依次类推。</p>
<p>(b)将每一个码点值作为右端点，每个分过程所得区间的宽度对应于该符号的概率。</p>
<p><strong>(3)对输入的每个信源符号，重复下述步骤</strong></p>
<p>`将第一个信源符号a2出现的概率空间[0.2 0.3)扩展为新的算法子空间，将当前分割为长度正比与信源集内各符号概率的区间；</p>
<p>接下来确定第二个符号a1的子区间，即序列a2a1的子区间</p>
<p>将a2a1的概率空间扩展为新的算法子空间；</p>
<p>确定信源符号序列a2a1a4的新算法子空间  ……go on</p>
<table>
<thead>
<tr>
<th>编码过程</th>
<th>输出数值范围</th>
</tr>
</thead>
<tbody><tr>
<td>初始</td>
<td>[0,1)</td>
</tr>
<tr>
<td>编码a2</td>
<td>[0.2,0.3)</td>
</tr>
<tr>
<td>编码a2a1</td>
<td>[0.2,0.22)</td>
</tr>
<tr>
<td>编码a2a1a4</td>
<td>[0.214,0.22)</td>
</tr>
<tr>
<td>编码a2a1a4a3</td>
<td>[0.2158,0.2182)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>那么任何一个该区间内的实数，如，0.2160就可以用来表示序列{a2a1a4a3}        </p>
<h2 id="2-3-1算术解码步骤"><a href="#2-3-1算术解码步骤" class="headerlink" title="2.3.1算术解码步骤"></a>2.3.1算术解码步骤</h2><p>`解码过程是对照当前的编码进行识别的过程</p>
<p>`当得到一个图像的编码后，根据其各个信源符号的概率进行分析，找到当前编码所符合的概率空间，逐步求精，即可以得到原始符号序列信息。</p>
<p>`解码过程如下;</p>
<p>​    1.通过比较各个信源符号与已知编码序列区间的数值范围，找到序列中第一个信源符号。</p>
<p>​    由于0.2158在[0.2,0.3)之间，所以，第一个符号是a2</p>
<p>​    2.从编码数值中减去第一个符号a2的影响，即首先减去a2左端0.2 再除以宽度0.1</p>
<p>​                == 0.158</p>
<p>​    3.0.158在a1区间，故第二个是0.158</p>
<table>
<thead>
<tr>
<th>被解码数值</th>
<th>解码信号源</th>
<th>输出数值范围</th>
</tr>
</thead>
<tbody><tr>
<td>0.2158</td>
<td>a2</td>
<td>[0.2,0.3)</td>
</tr>
<tr>
<td>0.158</td>
<td>a1</td>
<td>[0,0.2)</td>
</tr>
<tr>
<td>0.79</td>
<td>a4</td>
<td>[0.7,1)</td>
</tr>
<tr>
<td>0.3</td>
<td>a3</td>
<td>[0.3,0.7)</td>
</tr>
<tr>
<td>0</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>一个符号序列的末尾，应有一个结束符作为标志，它随信源符号一起被编码 </p>
<h2 id="2-3-2-算术编码分析"><a href="#2-3-2-算术编码分析" class="headerlink" title="2.3.2 算术编码分析"></a>2.3.2 算术编码分析</h2><p>`算术编码是一种从整个符号系列出发，采用递推形式连续编码的方法，在算术编码中，字母表中的符号和码字之间不再存在一一对应关系，一个算术编码字要赋给整个信源符号序列，(即不是一次编一个号)，而码字本身确定0和1之间的一个实数区间。</p>
<p>·不论是否是二元信源，也不论数据的概率分布如何，其平均码长均能逼近信源的熵。</p>
<p>`算术编码和霍夫曼编码的区别就在于：在算术编码中，输入序列的长度，是可以变化的，可以说，算术编码是将可变长码字赋给可变长符号块。</p>
<p>`正是由于算术编码不需要为定长符号快分配整数长的码字，理论上能达到无损编码定理所规定的最低限度。</p>
<p>`算术编码从全序列出发，采用递推形式的连续编码， 它不是将单个的信源符号映射成一个码字，而是将整 个符号序列映射为实数轴上[0,1）区间内的一个小区 间，其长度等于该序列的概率。 </p>
<p>`如果等整个符号序列输入完毕后再将最终得到的左端点 输出，将遇到两个问题：第一，当符号序列很长时，将 不能实时编解码；第二，有效位太长的数难以表示。 </p>
<p>`为了解决这个问题，通常采用两个有限精度的移位寄存 器存放码字的最新部分，随着序列中符号的不断输入， 不断地将其中的高位移出到信道上，以实现实时编解码。 </p>
<h2 id="2-3-2算术编码效率"><a href="#2-3-2算术编码效率" class="headerlink" title="2.3.2算术编码效率"></a>2.3.2算术编码效率</h2><p>`算术编码的最大优点之一在于它具有自适应性和高编码效率。 算术编码的模式选择直接影响编码效率。其模式有固定模式和自适 应模式两种。 固定模式是基于概率分布模型的，而在自适应模式中，其各符号的 初始概率都相同，但随着符号顺序的出现而改变，在无法进行信源 概率模型统计的条件下，非常适于使用自适应模式的算术编码。 </p>
<p>`在信道符号概率比较均匀的情况下，算术编码的编码效率 高于Huffman编码。但在实现上，比Huffman编码的计算过 程复杂。 </p>
<p>`算术码也是变长码，编码过程中的移位和输出都不均匀， 需要有缓冲存储器。 </p>
<p>`在误差扩散方面，也比分组码更严重。在分组码中，由于误 码而破坏分组，过一段时间后常能自动恢复；但在算术码中， 却往往会一直延续下去，因为它是从全序列出发来编码的。 因而算术码流的传输也要求高质量的信道，或采用检错反馈 重发的方式。 </p>
<h2 id="2-3-3算术编码举例"><a href="#2-3-3算术编码举例" class="headerlink" title="2.3.3算术编码举例"></a>2.3.3算术编码举例</h2><p>把区间［0.42688, 0.432］用二进制形式表示为 ［0.0110110101001,  0.011011101000011］。 （8）在这个区间中找出其编码最短的二进制作为算术编码。 可以看出，0.0110111是此区间最短的编码， 且算术编码中任一数 据序列的编码都含有“0.”，在编码时，可以不考虑“0.”，故把 0110111其作为数据序列“baacc”的算术编码。  </p>
<p>找最短编码，找出最短前缀，然后加上一个一即可。</p>
<h1 id="2-4游程编码"><a href="#2-4游程编码" class="headerlink" title="2.4游程编码"></a>2.4游程编码</h1><h2 id="游程编码概念"><a href="#游程编码概念" class="headerlink" title="游程编码概念"></a>游程编码概念</h2><p>​    将具有相同值的连续串用其串长和一个代表值来代替，该连续串就称为游程，串长称为游程长度</p>
<p>​    <strong>编码思想：去除像素冗余</strong></p>
<p>​    用游程的<strong>灰度</strong>和游程的<strong>长度</strong>代替游程本身。</p>
<p>​    </p>
<h2 id="二元信源的游程编码"><a href="#二元信源的游程编码" class="headerlink" title="二元信源的游程编码"></a>二元信源的游程编码</h2><p>​    000 100 111111 00000001</p>
<p>游程序列 3 1 2 6 7</p>
<p>等长游程编码： 011 001 010 110 111</p>
<h2 id="多元信源的游程编码"><a href="#多元信源的游程编码" class="headerlink" title="多元信源的游程编码"></a>多元信源的游程编码</h2><p>`对多元序列aabbbcddddd用游程编码</p>
<p>解:</p>
<p>​    游程长度编码为2a3b1c5d</p>
<p>` 例3：BBBBBBBBBBXXXXXXXXJJJJJAAAAAAUUUUUU • 经过游程编码后，变为： B#10X#8J#5A#6U#6 但是增加的标志位可能抵消压缩编码带来的好处，所以多元序列 进行游程编码的意义不大。 </p>
<h2 id="游程编码优缺点分析"><a href="#游程编码优缺点分析" class="headerlink" title="游程编码优缺点分析"></a>游程编码优缺点分析</h2><p>`游程编码仍然是变长编码，有其固定的缺点，需要大量缓冲和优质的信道。</p>
<p>`编码长度可以从1一直到无限，这在码字的选择和码表的建立方面都有困难，适用于二元序列，对于多元信源，一般不能直接利用游程编码。</p>
<h2 id="图像游程编码"><a href="#图像游程编码" class="headerlink" title="图像游程编码"></a>图像游程编码</h2><p>`对于某些灰度级成片连续出现的图像，游程编码也是一种高校的编码方法。特别是对二值图像，效果尤为显著</p>
<p>`游程编码所能获得的压缩比主要取决于图像本身的特点</p>
<p>`若图像中具有相同颜色的图像块越大，图像块数目越小，则压缩比就越高，。</p>
<p>`为了达到比较好的压缩效果，一般不单独使用游程编码，而是和其他编码方法结合使用。如在JPEG中就综合使用哈夫曼和游程编码。</p>
<p>​    </p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/三层交换机/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/三层交换机/" class="post-title-link" itemprop="url">三层交换机</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:28" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多端口路由器实现vlan间的通信过程"><a href="#多端口路由器实现vlan间的通信过程" class="headerlink" title="多端口路由器实现vlan间的通信过程"></a>多端口路由器实现vlan间的通信过程</h2><p>实现vlan间通信过程的思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vlan之间需要由路由设备互连</span><br><span class="line">不同vlan是逻辑上读里的不同网络 --&gt;</span><br><span class="line">不同网络必须配置不同的网络地址  --&gt;</span><br><span class="line">vlan之间通信必须经过路由器</span><br><span class="line"></span><br><span class="line">ps</span><br><span class="line">路由是指路由器从一个接口上接受到数据包，根据数据包的目的地址进行定向，并转发到另一个接口的过程。</span><br></pre></td></tr></table></figure>

<p>多端口路由器实现vlan间通信的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个终端都能与对应的路由器接口通信，</span><br><span class="line">	每一个vlan与一个路由器端口连接</span><br><span class="line">	每个与路由器相连的交换机端口都必须是接入端口</span><br></pre></td></tr></table></figure>

<p>这种网络结构的特点：</p>
<p>​    由于每一个vlan就是逻辑上的独立的以太网，因此，这种网络结构等同于路由器互联多个以太网，只管，简单，</p>
<p>​    由于vlan动态划分，设计网络是不知道vlan数目的，而且在网络使用过程中，vlan是随时变化的，路由器端口数五i发确定，</p>
<p>​    所有这种网络结构很难实施。</p>
<h2 id="单臂路由器实现vlan间通信过程"><a href="#单臂路由器实现vlan间通信过程" class="headerlink" title="单臂路由器实现vlan间通信过程"></a>单臂路由器实现vlan间通信过程</h2><p>VLAN动态性导致路由器端口数无法确定</p>
<p>多端口路由器实现VLAN互连是不可行的</p>
<p>—–&gt; 单端口实现VLAN互连</p>
<p>工作原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">单端口实现VLAN互连的方式称为单臂路由，单臂路由实现vlan通信需要解决如下问题：</span><br><span class="line"></span><br><span class="line">	1. 每个vlan至少连接一个路由端口。</span><br><span class="line">	2. 每一个路由接口对应唯一的vlan</span><br><span class="line">解决办法：</span><br><span class="line">	单个物理端口分解为多个逻辑接口，</span><br><span class="line">	每个逻辑接口绑定一个vlan</span><br><span class="line"></span><br><span class="line">1.每个逻辑接口配置一个ip地址和子网掩码</span><br><span class="line">2.与路由器相连的交换机端口必须是共享端口。</span><br><span class="line">3.路由器根据vlan标识符，确定接受MAC帧的逻辑接口。</span><br><span class="line"></span><br><span class="line">单臂路由的特点：</span><br><span class="line">解决了VLAN数量动态改变的问题</span><br><span class="line">带来了路由器和交换机之间链路宽带瓶颈问题。</span><br></pre></td></tr></table></figure>

<h2 id="三层交换机实现vlan之间通信过程"><a href="#三层交换机实现vlan之间通信过程" class="headerlink" title="三层交换机实现vlan之间通信过程"></a>三层交换机实现vlan之间通信过程</h2><p>​    三层交换机就是具有部分路由器功能的交换机，工作在osi网络标准模型的第三层，网络层。 </p>
<p>三层交换机由来</p>
<p>三层交换机配置</p>
<h2 id="互联设备之间的区别"><a href="#互联设备之间的区别" class="headerlink" title="互联设备之间的区别"></a>互联设备之间的区别</h2>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/路由表配置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/路由表配置/" class="post-title-link" itemprop="url">路由表配置</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:22:07" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="直连路由表自动生成过程"><a href="#直连路由表自动生成过程" class="headerlink" title="直连路由表自动生成过程"></a>直连路由表自动生成过程</h2><p>直连路由表，路由器接口直接连接的网络，这个在配置接口的时候会自动生成，比如说，一个接口连接的网络是 192.168.1.255/24 那么路由表自动生成</p>
<p>如下所示</p>
<p>目的网络        下一跳            输出接口</p>
<p>192.168.1.0      直接                1</p>
<h2 id="静态路由项手工配置过程"><a href="#静态路由项手工配置过程" class="headerlink" title="静态路由项手工配置过程"></a>静态路由项手工配置过程</h2><p>非直连的路由表，需要人工添加路由表项目，比如</p>
<p>目的网络                下一跳            输出接口</p>
<p>192.1.1.0/24        192.1.4.1        1   </p>
<p>从输出接口1出去，可以到达192.1.4.1 然后进而到达目的网络</p>
<h2 id="Cisco路由器静态路由项配置过程"><a href="#Cisco路由器静态路由项配置过程" class="headerlink" title="Cisco路由器静态路由项配置过程"></a>Cisco路由器静态路由项配置过程</h2><p>## </p>
<h2 id="路由协议与动态路由项"><a href="#路由协议与动态路由项" class="headerlink" title="路由协议与动态路由项"></a>路由协议与动态路由项</h2><p>静态路由项，人工配置，带来的问题</p>
<p>~大型网络中人工配置的工作量巨大</p>
<p>~很难保证各个路由器路由表的一致性</p>
<p>~静态路由项无法根据网络规模动态改变</p>
<p>因此 路由器中的路由项主要通过路由协议动态生成。</p>
<p>RIP—路由信息协议</p>
<p>route information principal</p>
<p>RIP创建动态路由项过程</p>
<p>步骤：</p>
<p>每一个路由器建立直接连接的子网的路由项。</p>
<p>相邻路由器交换各自的路由项，如果相邻路由器路由项中存在通往某个子网的路径，那么意味着通过该相邻路由器可以找到通往该子网的路径</p>
<p>通过周期性的反复交换路由项，最终建立到达网络中所有子网的路由项目。</p>
<p>路由器把自己的路由表封装成ip数据包，然后目的地址是组播地址，源地址是路由器传出去的接口的地址。</p>
<p>周围的路由器接受到以后，看它的路由表，把自己没有的项加入，如果有了的，看一下距离是不是更小，更小就应该替换。</p>
<p>距离向量算法。</p>
<p>对每一个相邻路由器发送过来的rip报文，进行以下步骤：</p>
<ol>
<li><p>对地址为x的相邻路由器发来的rip报文，先修改这个报文中所有的项目，把下一跳字段中的地址都改为x,并且把所有跳数，即距离，增加一，每一个项目都有三个关键数据，也就是</p>
<p>到目的网络N      距离是d    下一跳路由器是X</p>
</li>
<li><p>对修改后的RIP报文中的每一个项目，进行以下步骤，没有的，加</p>
<p>有的，看下一跳，如果是X，则替换原来的，如果不是X，看是否小于当前表中的d</p>
</li>
<li><p>如果3分钟没有收到相邻路由器的更新路由表，则把这个相邻路由器记为不可达的路由器，即把距离设置成为16。</p>
</li>
</ol>
<p>几点解释：</p>
<p>​    为什么要替换，因为这是最新消息，要以最新的消息为准，到目的网络的距离有可能变大也有可能减小，但是也可能没有改变，但是不管是怎样，都要更新为现在的消息。</p>
<p>​    </p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
    <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="aaaaltaaaa">
  
  <p class="site-author-name" itemprop="name">aaaaltaaaa</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>


  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>







  <div class="links-of-author motion-element">
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/aaaaltaaaa" title="GitHub &rarr; https://github.com/aaaaltaaaa" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>







          
          
        </div>
      </div>

      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaaaltaaaa</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  





  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  

  

  

  

  



  




  




  




  






  

  

  


  

</body>
</html>
