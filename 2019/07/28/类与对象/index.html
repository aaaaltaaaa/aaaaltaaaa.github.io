<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">






<link rel="stylesheet" href="/css/main.css?v=7.2.0">






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">








<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="程序抽象与面向对象抽象数据类型类的概念与意义：属性和行为的辩证统一 对象首先要表达的是量的概念，而行为具有主动性，不是在一个对象上施加操作，而是对象自己进行行为。 一个是被动一个是主动。 类类型 类的声明：仅仅声明类的存在，没有提供细节 关键字：class 示例：class A; 类定义-一般定义格式，类成员，三个保留字顺序任意。 public  protected private 没有定义访问控">
<meta name="keywords" content="面向对象程序设计">
<meta property="og:type" content="article">
<meta property="og:title" content="程序抽象与面向对象">
<meta property="og:url" content="http://yoursite.com/2019/07/28/类与对象/index.html">
<meta property="og:site_name" content="博学之,审问之,慎思之,明辨之,笃行之">
<meta property="og:description" content="程序抽象与面向对象抽象数据类型类的概念与意义：属性和行为的辩证统一 对象首先要表达的是量的概念，而行为具有主动性，不是在一个对象上施加操作，而是对象自己进行行为。 一个是被动一个是主动。 类类型 类的声明：仅仅声明类的存在，没有提供细节 关键字：class 示例：class A; 类定义-一般定义格式，类成员，三个保留字顺序任意。 public  protected private 没有定义访问控">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-07-28T09:22:02.518Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序抽象与面向对象">
<meta name="twitter:description" content="程序抽象与面向对象抽象数据类型类的概念与意义：属性和行为的辩证统一 对象首先要表达的是量的概念，而行为具有主动性，不是在一个对象上施加操作，而是对象自己进行行为。 一个是被动一个是主动。 类类型 类的声明：仅仅声明类的存在，没有提供细节 关键字：class 示例：class A; 类定义-一般定义格式，类成员，三个保留字顺序任意。 public  protected private 没有定义访问控">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/07/28/类与对象/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>程序抽象与面向对象 | 博学之,审问之,慎思之,明辨之,笃行之</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博学之,审问之,慎思之,明辨之,笃行之</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">aaaaltaaaaの博客</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/类与对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">程序抽象与面向对象

              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:22:02" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="程序抽象与面向对象"><a href="#程序抽象与面向对象" class="headerlink" title="程序抽象与面向对象"></a>程序抽象与面向对象</h2><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>类的概念与意义：属性和行为的辩证统一</p>
<p>对象首先要表达的是量的概念，而行为具有主动性，不是在一个对象上施加操作，而是对象自己进行行为。</p>
<p>一个是被动一个是主动。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p> 类的声明：仅仅声明类的存在，没有提供细节</p>
<p>关键字：class</p>
<p>示例：class A;</p>
<p>类定义-一般定义格式，类成员，三个保留字顺序任意。</p>
<p>public  protected private</p>
<p>没有定义访问控制的  class里面 缺省private </p>
<p>​            struct  缺省是public</p>
<p>this指针：指向当前对象的指针，  引领有成员，用来区分形式参数</p>
<p>仅限于函数圆形使用类类型的生命，不能用于定义类的数据成员。</p>
<p>（定义数据对象就要知道怎么分配）</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>####　对象的定义</p>
<p>相结构体一样定义和使用对象及其公开的成员</p>
<p>私有成员不可在　对象外部直接访问</p>
<p>对象构造的意义：构造就是初始化，在定义对象是初始化　数据成员</p>
<p>对象构造的技术手段：使用构造函数</p>
<p>与类类型同名，没有返回值类型</p>
<p>构造函数允许重载</p>
<p>构造函数可以带缺省参数，但是不建议</p>
<p>至少公开一个构造函数。</p>
<p>只能由系统在创建对象时自动调用，程序其他部分不能直接调用。</p>
<p>缺省构造函数，自动构造，分配好内存空间。</p>
<p>拷贝构造函数，仅限于构造已有对象的副本</p>
<p>拷贝构造函数单参数，为本类的常　对象的引用</p>
<p>如未定义，系统自动生成一个缺省的拷贝构造函数。</p>
<p>缺省的拷贝构造函数是一个位拷贝，直接将存储区的内容，一个字节一个字节的完全的拷贝。－－－层次不够深，称为浅拷贝　ｗｈｙ？</p>
<p>如果类的申明里面带有一个指针，这个指针指向一个动态分配的目标数据对象，</p>
<p>拷贝指针的值还是拷贝指针指向的动态分配的　数据对象？？？</p>
<p>浅拷贝只能完成指针值的拷贝。！</p>
<p>想实现拷贝目标数据对象，需要自己完成拷贝函数。</p>
<h2 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h2><p>####　初始化与复制的区别</p>
<p>１）初始化：一个变量或者一个对象产生的时候就赋予一个值，属于伴随性质</p>
<p>２）赋值：在一个变量或者一个对象在产生之后的仍以时刻赋予一个值，属于任意性质</p>
<p>宏观上：</p>
<p>１）两者作用相同</p>
<p>２）对于数组和结构体来说，初始化和赋值的形式不同。对于数组，可以使用花括号一起初始化，如果赋值的话，就只能单个元素，对于结构体，可以使用花括号进行初始化，否则只能通过“.”来访问变量进行赋值。</p>
<p>３）对于引用和const常量来说，只能初始化，不能赋值</p>
<h4 id="类中的变量初始化"><a href="#类中的变量初始化" class="headerlink" title="类中的变量初始化"></a>类中的变量初始化</h4><p>１）一般情况下，声明一个类是并不占用内存的，如果直接在类中给变量初始化也是不允许的。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数也是一个函数：</p>
<p>１）函数的名字与类相同</p>
<p>２）在创建一个对象的时候，构造函数就会自动执行，但是在声明一个类的指针对象的时候，构造函数不会被调用，当ｎｅｗ一个空间的时候，构造函数才会被调用</p>
<p>３）构造函数一般用来对数据成员的赋值</p>
<p>４）构造函数没有返回值</p>
<p>５）一个类里面也可以有多个构造函数，这些构造函数根据参数的不同，构成重载，根据参数的传递来选择调用哪个构造函数。</p>
<p>６）可以不用显示的定义构造函数，这种情况下，编译器回自动帮我们生成一个空构造函数，如果我们声明了一个构造函数，那么会自动覆盖空的构造函数</p>
<p>###　构造函数的类型</p>
<p>虽然构造函数没有返回值，但可以有参数，如果构造函数有参数，那么在创建对象时，就一定要传入参数，否则会报错，</p>
<p>同时，构造函数也可以制定形参末日使者，在参数不够时，就使用默认值，这一点与基本的函数相同，也可以重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a1 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">float</span> b1 = <span class="number">3.14f</span>;</span><br><span class="line">	<span class="function">Cperson <span class="title">op1</span><span class="params">(a1, b1)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; op1.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; op1.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Cperson *op2;             <span class="comment">//构造函数没有被调用</span></span><br><span class="line">	op2 = <span class="keyword">new</span> Cperson(a1, b1);        <span class="comment">//构造函数被调用</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; op2-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; op2-&gt;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-初始化列表"><a href="#4-初始化列表" class="headerlink" title="4.初始化列表"></a>4.初始化列表</h3><p>作用：</p>
<p>对数据成员进行初始化</p>
<p>格式：</p>
<p>构造函数():变量名(),变量名()</p>
<p>传递参数初始化列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cperson(<span class="keyword">int</span> aa, <span class="keyword">float</span> bb, <span class="built_in">string</span> cc) :_a(aa), _b(bb), _c(cc)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Pay attention:</p>
<p>１．在构造函数执行时，先执行初始化列表，实现变量的初始化，然后才执行函数内部的语句</p>
<p>２．成员初始化的顺序只与声明的顺序有关，而跟初始化列表的顺序无关，</p>
<p>３．成员支架可以相互初始化　（类型相同）</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Cperson():_b(<span class="number">12</span>),_a(_b)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; _a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; _b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _a;</span><br><span class="line">	<span class="keyword">int</span> _b;</span><br></pre></td></tr></table></figure>

<p>结果会出错，因为先给_a赋值，此时_b没有初始化。是个随机的</p>
<h3 id="6引用和常量的初始化"><a href="#6引用和常量的初始化" class="headerlink" title="6引用和常量的初始化"></a>6引用和常量的初始化</h3><p>１）当类成员中有常量和引用时，一定要初始化，否则会报错。</p>
<h2 id="7-数组初始化"><a href="#7-数组初始化" class="headerlink" title="7.数组初始化"></a>7.数组初始化</h2><p>格式：构造函数():数组名()//后面的括号得是空的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cperson():a()</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>结构体的初始化</p>
<p>##　对象的析构</p>
<p>－析构就是终止化，在对象生命期结束时清楚它。</p>
<p>－对象析构的技术手段：使用析构函数</p>
<p>​    －与类类型同名，前面有~　无返回值无参数</p>
<p>​    必须公开</p>
<p>可以由系统在销毁对象时调用，也可以由程序其他地方调用，但是两者工作原理不同</p>
<p>每个类只能有一个析构函数</p>
<p>如果未定义，系统自动生成，无代码</p>
<h3 id="定义析构函数的目的"><a href="#定义析构函数的目的" class="headerlink" title="定义析构函数的目的"></a>定义析构函数的目的</h3><p>​    －用于释放对象中动态分配内存的目标数据对象</p>
<p>对象数组，构造函数单参数：可以像数组一样初始化</p>
<p>多参数，类似结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle circles[2] = &#123;Circle(1,1),Circle(1,1)&#125;</span><br></pre></td></tr></table></figure>

<p>#　类与对象的成员</p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">目的：程序优化，展开函数代码而不是调用</span><br><span class="line">内联函数使用的注意事项：</span><br><span class="line">	在函数定义前添加　inline关键字，仅在函数原型前使用此关键字无效。</span><br><span class="line">	编译器必须能看见内联函数的代码才能在编译期展开，内联函数必须实现在头文件中。</span><br><span class="line">	在类定义中给出函数体的成员函数自动成为内联函数。</span><br><span class="line">	构造函数和析构函数有可能隐含附加操作，慎用内联</span><br><span class="line">	内联函数仅是建议，　编译器会自助选择是否内联</span><br><span class="line">	函数体代码量较大，或包含循环，不要使用内联</span><br></pre></td></tr></table></figure>

<h5 id="内联函数定义"><a href="#内联函数定义" class="headerlink" title="内联函数定义"></a>内联函数定义</h5><p>​        inline是C++语言中的一个关键字，可以用于程序中定义内联函数，inline的引进使定义内联函数的定义更加简单，</p>
<p>​        内联函数，是C++中的一种特殊函数，它可以像普通函数一样被调用，但是在调用时并不通过函数调用机制，而是通过将函数体直接插入调用处来实现的，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率，一般inline用于定义类的成员函数</p>
<h4 id="inine的基本使用"><a href="#inine的基本使用" class="headerlink" title="inine的基本使用"></a>inine的基本使用</h4><p>inline的使用比较简单，只需要在声明或者定义时在头部加上inline关键字即可，格式如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span>　返回值　函数名（参数）｛</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>一般来说　,inline适用的函数有两种，一种是在类内定义的成员函数，另一种是在类内声明，类外定义的成员函数，</p>
<p>(1)类内定义成员函数</p>
<p>​    这种情况下，我们可以不用在函数头部加inline关键字，因为编译器会自动将类内定义的函数声明为内联函数，代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">temp</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">int</span> amount;</span><br><span class="line">    temp(<span class="keyword">int</span> amount)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;amout = amout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通成员函数，在类内定义时前面可以不加inline</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_amount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>-&gt;amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可看出，在类内定义函数时，可以不加inline关键字，编译器会自动将类内定义的函数(构造函数，析构函数，普通成员函数)设置为内联，具有内联函数调用的性质，</p>
<p>（２）类内声明函数，在类外定义函数</p>
<p>​            根据C++编译器的规则，这种情况下如果将该函数设置为内联函数，则可以在类内声明时不加inline关键字，而在类外定义时候加上关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">temp</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">int</span> amount;</span><br><span class="line">   	temp(<span class="keyword">int</span> amount)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;aout=amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_amount</span><span class="params">()</span></span>;<span class="comment">//普通成员函数，在类内声明前面可以不加ｉｎｌｉｎｅ</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> temp::print_amount()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;amount&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码我们可以看出，类内声明可以不用加上inline关键字，但是类外定义时必须加上，这样才能保证编译器能够识别其为内联函数。    </p>
<p>​    另外，我们可以在声明函数和定义函数的同时写inline,　也可以在声明时加，定义时不加，只要在调用该函数之前把inline的信息告知编译系统，编译系统就会在处理函数调用时按内联函数处理。也就是说，上面说的几种方法都可以实现一个内联函数的定义，根据自己的需要来写即可。</p>
<h4 id="3-内联函数的优缺点"><a href="#3-内联函数的优缺点" class="headerlink" title="3.内联函数的优缺点"></a>3.内联函数的优缺点</h4><p>优点：</p>
<p>​        １.inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，没有了调用的开销，效率也很高。</p>
<p>​        ２.很明显，类的内联函数是一个真正的函数，编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确，然后进行一系列的相关检查，就像对待任何一个真正的函数一样，这样就消除了它的隐患和局限性，</p>
<p>​        ３．inline函数可以作为一个类的成员函数，与类的普通成员函数作用相同，可以访问一个类的私有成员和保护成员，类联函数可以用于替换一般的宏定义，最重要的应用在于类的存取函数的定义上面。</p>
<p>缺点：</p>
<p>​        １.内联函数具有一定的局限性，内联函数的函数体一般来说不能太大，如果内联函数的函数体过大，一般编译器会放弃内联方式，而采用普通的方式调用函数，</p>
<p>​        ２．ｉｎｌｉｎｅ对于编译器来说只是一个建议，</p>
<p>###　４内联函数和宏定义的区别</p>
<p>​        内联函数和宏的区别在于，</p>
<p>​        宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。</p>
<p>​        而且内联函数是真正的函数，只是在需要用到的时候，内联函数回想宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销，</p>
<p>​        你可以像调用函数一样来调用内联函数，而不必担心处理宏的一些问题，内联函数与带参数的宏定义进行下比较，他们的代码效率是一样的，但是内联函数遵循的类型和作用于规则，它与一般函数更相近，在一些编译器中，一旦关联上内联扩展，将与一般函一样进行调用，比较方便。</p>
<p>​        另外，宏定义在使用时只是简单的文本替换，并没有做严格的参数检查，也就不能享受Ｃ＋＋编译器的严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p>
<p>​        Ｃ＋＋的内联就是为了完全取代了宏定义，，，ｅｆｆｅｃｔｉｖｅ　Ｃ＋＋</p>
<p>中提到了尽量使用ｉｎｌｉｎｅ代替宏定义。</p>
<h3 id="5使用注意事项"><a href="#5使用注意事项" class="headerlink" title="5使用注意事项"></a>5使用注意事项</h3><p>１.内联函数不能包括复杂的控制语句，如循环语句和ｓｗｉｔｃｈ语句</p>
<p>２.内联函数不能包括复杂的控制语句，如循环语句和ｓｗｉｔｃｈ语句</p>
<p>３.只将规模很小，而使用频繁的函数声明为内联函数，在函数规模很小的　情况下，函数调用时间开销可能甚至超过执行函数本身的时间。</p>
<h3 id="常数据成员"><a href="#常数据成员" class="headerlink" title="常数据成员"></a>常数据成员</h3><p>常数据成员：值在程序运行期间不可变</p>
<p>定义格式：const 类型　　数据成员名称；</p>
<p><strong>初始化：只能通过构造函数中的初始化列表进行</strong></p>
<h3 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h3><p>不能修改对象成员值的函数</p>
<p>－定义格式：类型　　成员函数名称(参数列表)　　const;</p>
<p>－常成员函数不能调用类中非常成员函数</p>
<p>－静态成员函数不能定义为常成员函数</p>
<p>－如果对象为常量，则只能调用其常成员函数。</p>
<h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><p>静态数据成员只有一份，由该类所有对象共享，</p>
<p>－声明格式：static　类型　静态数据成员名称</p>
<p>－仅声明，　不在对象上分配空间</p>
<p>－定义格式：　类型　类名称::静态数据成员名称　＝　　初始值</p>
<p>－必须在外部初始化，初始化与访问控制无关</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;			</span><br><span class="line"><span class="keyword">int</span> A::count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>－在类而不是对象上调用</p>
<p>－目的：访问类的静态数据成员，若要访问类的非静态数据成员，必须制定对象或者使用指向对象的指针。</p>
<h2 id="单子模式"><a href="#单子模式" class="headerlink" title="单子模式"></a>单子模式</h2><p>只存在某类的单一共享对象</p>
<p>存在某种全局访问策略，以在需要时访问对象</p>
<p>程序中只存在一个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单子模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> SAingle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="继承的基本概念"><a href="#继承的基本概念" class="headerlink" title="继承的基本概念"></a>继承的基本概念</h4><p>类类型：描述分类的概念</p>
<p>继承：描述类之间的血缘关系</p>
<p>基类，派生类：</p>
<p>父类，子类</p>
<p>继承的意义</p>
<p>－派生类可以拥有基类的全部属性和行为，可以添加自己的属性和行为。</p>
<p>只能添加新的功能不能取消已有的！！**</p>
<p>###　单继承</p>
<p>class 派生类名称: 派生类保留字　基类名称{};</p>
<p><strong>保留字</strong></p>
<p>public:</p>
<p>​    基类的ｐｕｂｌｉｃ，ｐｒｏｔｅｃｔｅｄ成员在派生类中不可见</p>
<p>protected </p>
<p>​        基类的ｐｒｉｖａｔｅ成员在派生类中不可见，ｐｕｂｌｉｃ，ｐｒｏｔｅｃｔｅｄ变为ｐｒｏｔｅｃｔｅｄ</p>
<p>private</p>
<p>​        基类的ｐｒｉｖａｔｅ成员在派生类中间那个不可见，ｐｕｂｌｉｃ，ｐｒｏｔｅｃｔｅｄ成员在派生类中间那个变为ｐｒｉｖａｔｅ成员</p>
<p>－设计类时若需要使用继承机制，建议将派生类需要频繁使用的基类设为ｐｒｏｔｅｃｔｅｄ。</p>
<p>###　函数的覆盖与二义性</p>
<p>１．派生类成员函数名称与基类相同</p>
<p>　　如果派生类要调用基类的同名成员函数</p>
<p>pt.Point::Print()</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承的基本语法格式</p>
<p>class 派生类名称:派生类型保留字　　基类名称１　派生类型保留字　基类名称２，。。｛｝</p>
<p>多继承导致问题：派生类中可能有多个基类副本</p>
<p>class A{}; class　Ｂ:public A{};</p>
<p>class C:public A,protected  B{};</p>
<p>二义性　　同单继承差不多</p>
<p>d.B::A::f()</p>
<h3 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h3><p>目的:取消多继承时派生类中　公共基类的多个副本，只保留一份</p>
<p>格式：派生时使用关键字　virtual　</p>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;<span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;<span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B,<span class="keyword">public</span> C&#123;<span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;;</span><br></pre></td></tr></table></figure>

<p>Ｂ类的对象上所有Ａ类副本只有一个</p>
<p>Ｃ类的对象上所有Ａ类副本只有一个</p>
<p>Ｄ类只有Ａ类的一个副本</p>
<h3 id="派生类的构造函数和析构函数"><a href="#派生类的构造函数和析构函数" class="headerlink" title="派生类的构造函数和析构函数"></a>派生类的构造函数和析构函数</h3><p>构造函数的执行顺序</p>
<p>－调用基类的构造函数，调用孙旭与基类在派生类中j</p>
<p>－调用派生类新增对象成员的构造函数，调用顺序与其在派生类中的定义顺序相同。</p>
<p>－调用派生类的构造函数；</p>
<p>析构函数的执行顺序</p>
<p>－调用派生类的析构函数</p>
<p>－调用派生类新增对象成员的析构函数，调用书序与其在派生类中定义顺序相反</p>
<p>－调用基类的析构函数，调用顺序与</p>
<h3 id="类的赋值兼容性"><a href="#类的赋值兼容性" class="headerlink" title="类的赋值兼容性"></a>类的赋值兼容性</h3><p>公有派生时，任何基类对象可以出现的位置都可以使用派生类对象代替。</p>
<p>－将派生类对象赋值给积累对象，仅赋值基类部分</p>
<p>－用派生类对象<strong>初始化基类对象引用</strong>，仅操作基类部分</p>
<p>－<strong>使指向基类的指针指向派生类对象</strong>，仅引领基类部分</p>
<p>００１２</p>
<p>保护派生与私有派生不可以直接赋值</p>
<p>－尽量不要使用保护派生与私有派生。　</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态性:</p>
<p>－目的：不同对象在接受到相同消息时做不同响应</p>
<p>－现象：对应同样成员函数名称，执行不同函数体</p>
<p>多态性的实现</p>
<p>－虚函数：使用ｖｉｒｔｕａｌ关键字声明成员函数</p>
<p>－声明格式:　virtual 函数返回值　函数名称(参数列表)；</p>
<p>效果：指向基类的指针，自动调用目标类</p>
<p>如果基类中有一个虚函数，派生类不想用？不写就行了</p>
<p><strong>纯虚函数</strong></p>
<p>－充当占位函数，没有任何实现</p>
<p>－派生类负责实现其具体功能</p>
<p>比如ａｃｃｏｕｎｔ实际上是不存在的　实际上　用的要么是ｃｈｅｃｋｉｎｇ　要么是ｓａｖｉｎｇ</p>
<p>声明格式:virtual void f(int x) = 0;//纯虚函数不能调用，但是其指针是存在的，</p>
<p><strong>抽象类</strong></p>
<p>－带有纯虚函数的类　//绝对不可能构造这样的一个对象</p>
<p>-作为类继承层次的上层。</p>
<p>虚析构函数</p>
<p>－保持多态性需要虚析构函数，以保证能够正确释放对象。</p>

      
    </div>

    

    
      
    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/面向对象程序设计/" rel="tag"># 面向对象程序设计</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/28/分布式计算4/" rel="next" title="分布式计算4">
                <i class="fa fa-chevron-left"></i> 分布式计算4
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/28/路由表配置/" rel="prev" title="路由表配置">
                路由表配置 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
    <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="aaaaltaaaa">
  
  <p class="site-author-name" itemprop="name">aaaaltaaaa</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>


  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>







  <div class="links-of-author motion-element">
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/aaaaltaaaa" title="GitHub &rarr; https://github.com/aaaaltaaaa" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>







          
          
        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#程序抽象与面向对象"><span class="nav-number">1.</span> <span class="nav-text">程序抽象与面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象数据类型"><span class="nav-number">1.1.</span> <span class="nav-text">抽象数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类类型"><span class="nav-number">1.2.</span> <span class="nav-text">类类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象"><span class="nav-number">1.3.</span> <span class="nav-text">对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数的初始化列表"><span class="nav-number">2.</span> <span class="nav-text">构造函数的初始化列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类中的变量初始化"><span class="nav-number">2.0.1.</span> <span class="nav-text">类中的变量初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数"><span class="nav-number">2.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-初始化列表"><span class="nav-number">2.2.</span> <span class="nav-text">4.初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6引用和常量的初始化"><span class="nav-number">2.3.</span> <span class="nav-text">6引用和常量的初始化</span></a></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#7-数组初始化"><span class="nav-number">3.</span> <span class="nav-text">7.数组初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义析构函数的目的"><span class="nav-number">3.1.</span> <span class="nav-text">定义析构函数的目的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内联函数"><span class="nav-number">4.</span> <span class="nav-text">内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内联函数定义"><span class="nav-number">4.0.0.1.</span> <span class="nav-text">内联函数定义</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inine的基本使用"><span class="nav-number">4.0.1.</span> <span class="nav-text">inine的基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-内联函数的优缺点"><span class="nav-number">4.0.2.</span> <span class="nav-text">3.内联函数的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5使用注意事项"><span class="nav-number">4.1.</span> <span class="nav-text">5使用注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常数据成员"><span class="nav-number">4.2.</span> <span class="nav-text">常数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常成员函数"><span class="nav-number">4.3.</span> <span class="nav-text">常成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态数据成员"><span class="nav-number">4.4.</span> <span class="nav-text">静态数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态成员函数"><span class="nav-number">4.5.</span> <span class="nav-text">静态成员函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单子模式"><span class="nav-number">5.</span> <span class="nav-text">单子模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">6.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#继承的基本概念"><span class="nav-number">6.0.1.</span> <span class="nav-text">继承的基本概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多继承"><span class="nav-number">6.1.</span> <span class="nav-text">多继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚基类"><span class="nav-number">6.2.</span> <span class="nav-text">虚基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#派生类的构造函数和析构函数"><span class="nav-number">6.3.</span> <span class="nav-text">派生类的构造函数和析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的赋值兼容性"><span class="nav-number">6.4.</span> <span class="nav-text">类的赋值兼容性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态"><span class="nav-number">6.5.</span> <span class="nav-text">多态</span></a></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaaaltaaaa</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  





  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  
  <script src="/js/scrollspy.js?v=7.2.0"></script>
<script src="/js/post-details.js?v=7.2.0"></script>



  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  

  

  

  

  


  


  




  




  




  






  

  

  


  

</body>
</html>
