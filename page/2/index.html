<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">






<link rel="stylesheet" href="/css/main.css?v=7.2.0">






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">








<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="博学之,审问之,慎思之,明辨之,笃行之">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="博学之,审问之,慎思之,明辨之,笃行之">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="博学之,审问之,慎思之,明辨之,笃行之">





  
  
  <link rel="canonical" href="http://yoursite.com/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  
  <title>博学之,审问之,慎思之,明辨之,笃行之</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博学之,审问之,慎思之,明辨之,笃行之</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">aaaaltaaaaの博客</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/类与对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/类与对象/" class="post-title-link" itemprop="url">程序抽象与面向对象</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:22:02" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="程序抽象与面向对象"><a href="#程序抽象与面向对象" class="headerlink" title="程序抽象与面向对象"></a>程序抽象与面向对象</h2><h3 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h3><p>类的概念与意义：属性和行为的辩证统一</p>
<p>对象首先要表达的是量的概念，而行为具有主动性，不是在一个对象上施加操作，而是对象自己进行行为。</p>
<p>一个是被动一个是主动。</p>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p> 类的声明：仅仅声明类的存在，没有提供细节</p>
<p>关键字：class</p>
<p>示例：class A;</p>
<p>类定义-一般定义格式，类成员，三个保留字顺序任意。</p>
<p>public  protected private</p>
<p>没有定义访问控制的  class里面 缺省private </p>
<p>​            struct  缺省是public</p>
<p>this指针：指向当前对象的指针，  引领有成员，用来区分形式参数</p>
<p>仅限于函数圆形使用类类型的生命，不能用于定义类的数据成员。</p>
<p>（定义数据对象就要知道怎么分配）</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>####　对象的定义</p>
<p>相结构体一样定义和使用对象及其公开的成员</p>
<p>私有成员不可在　对象外部直接访问</p>
<p>对象构造的意义：构造就是初始化，在定义对象是初始化　数据成员</p>
<p>对象构造的技术手段：使用构造函数</p>
<p>与类类型同名，没有返回值类型</p>
<p>构造函数允许重载</p>
<p>构造函数可以带缺省参数，但是不建议</p>
<p>至少公开一个构造函数。</p>
<p>只能由系统在创建对象时自动调用，程序其他部分不能直接调用。</p>
<p>缺省构造函数，自动构造，分配好内存空间。</p>
<p>拷贝构造函数，仅限于构造已有对象的副本</p>
<p>拷贝构造函数单参数，为本类的常　对象的引用</p>
<p>如未定义，系统自动生成一个缺省的拷贝构造函数。</p>
<p>缺省的拷贝构造函数是一个位拷贝，直接将存储区的内容，一个字节一个字节的完全的拷贝。－－－层次不够深，称为浅拷贝　ｗｈｙ？</p>
<p>如果类的申明里面带有一个指针，这个指针指向一个动态分配的目标数据对象，</p>
<p>拷贝指针的值还是拷贝指针指向的动态分配的　数据对象？？？</p>
<p>浅拷贝只能完成指针值的拷贝。！</p>
<p>想实现拷贝目标数据对象，需要自己完成拷贝函数。</p>
<h2 id="构造函数的初始化列表"><a href="#构造函数的初始化列表" class="headerlink" title="构造函数的初始化列表"></a>构造函数的初始化列表</h2><p>####　初始化与复制的区别</p>
<p>１）初始化：一个变量或者一个对象产生的时候就赋予一个值，属于伴随性质</p>
<p>２）赋值：在一个变量或者一个对象在产生之后的仍以时刻赋予一个值，属于任意性质</p>
<p>宏观上：</p>
<p>１）两者作用相同</p>
<p>２）对于数组和结构体来说，初始化和赋值的形式不同。对于数组，可以使用花括号一起初始化，如果赋值的话，就只能单个元素，对于结构体，可以使用花括号进行初始化，否则只能通过“.”来访问变量进行赋值。</p>
<p>３）对于引用和const常量来说，只能初始化，不能赋值</p>
<h4 id="类中的变量初始化"><a href="#类中的变量初始化" class="headerlink" title="类中的变量初始化"></a>类中的变量初始化</h4><p>１）一般情况下，声明一个类是并不占用内存的，如果直接在类中给变量初始化也是不允许的。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数也是一个函数：</p>
<p>１）函数的名字与类相同</p>
<p>２）在创建一个对象的时候，构造函数就会自动执行，但是在声明一个类的指针对象的时候，构造函数不会被调用，当ｎｅｗ一个空间的时候，构造函数才会被调用</p>
<p>３）构造函数一般用来对数据成员的赋值</p>
<p>４）构造函数没有返回值</p>
<p>５）一个类里面也可以有多个构造函数，这些构造函数根据参数的不同，构成重载，根据参数的传递来选择调用哪个构造函数。</p>
<p>６）可以不用显示的定义构造函数，这种情况下，编译器回自动帮我们生成一个空构造函数，如果我们声明了一个构造函数，那么会自动覆盖空的构造函数</p>
<p>###　构造函数的类型</p>
<p>虽然构造函数没有返回值，但可以有参数，如果构造函数有参数，那么在创建对象时，就一定要传入参数，否则会报错，</p>
<p>同时，构造函数也可以制定形参末日使者，在参数不够时，就使用默认值，这一点与基本的函数相同，也可以重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a1 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">float</span> b1 = <span class="number">3.14f</span>;</span><br><span class="line">	<span class="function">Cperson <span class="title">op1</span><span class="params">(a1, b1)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; op1.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; op1.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Cperson *op2;             <span class="comment">//构造函数没有被调用</span></span><br><span class="line">	op2 = <span class="keyword">new</span> Cperson(a1, b1);        <span class="comment">//构造函数被调用</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; op2-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; op2-&gt;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-初始化列表"><a href="#4-初始化列表" class="headerlink" title="4.初始化列表"></a>4.初始化列表</h3><p>作用：</p>
<p>对数据成员进行初始化</p>
<p>格式：</p>
<p>构造函数():变量名(),变量名()</p>
<p>传递参数初始化列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cperson(<span class="keyword">int</span> aa, <span class="keyword">float</span> bb, <span class="built_in">string</span> cc) :_a(aa), _b(bb), _c(cc)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Pay attention:</p>
<p>１．在构造函数执行时，先执行初始化列表，实现变量的初始化，然后才执行函数内部的语句</p>
<p>２．成员初始化的顺序只与声明的顺序有关，而跟初始化列表的顺序无关，</p>
<p>３．成员支架可以相互初始化　（类型相同）</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Cperson():_b(<span class="number">12</span>),_a(_b)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; _a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; _b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _a;</span><br><span class="line">	<span class="keyword">int</span> _b;</span><br></pre></td></tr></table></figure>

<p>结果会出错，因为先给_a赋值，此时_b没有初始化。是个随机的</p>
<h3 id="6引用和常量的初始化"><a href="#6引用和常量的初始化" class="headerlink" title="6引用和常量的初始化"></a>6引用和常量的初始化</h3><p>１）当类成员中有常量和引用时，一定要初始化，否则会报错。</p>
<h2 id="7-数组初始化"><a href="#7-数组初始化" class="headerlink" title="7.数组初始化"></a>7.数组初始化</h2><p>格式：构造函数():数组名()//后面的括号得是空的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cperson():a()</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>结构体的初始化</p>
<p>##　对象的析构</p>
<p>－析构就是终止化，在对象生命期结束时清楚它。</p>
<p>－对象析构的技术手段：使用析构函数</p>
<p>​    －与类类型同名，前面有~　无返回值无参数</p>
<p>​    必须公开</p>
<p>可以由系统在销毁对象时调用，也可以由程序其他地方调用，但是两者工作原理不同</p>
<p>每个类只能有一个析构函数</p>
<p>如果未定义，系统自动生成，无代码</p>
<h3 id="定义析构函数的目的"><a href="#定义析构函数的目的" class="headerlink" title="定义析构函数的目的"></a>定义析构函数的目的</h3><p>​    －用于释放对象中动态分配内存的目标数据对象</p>
<p>对象数组，构造函数单参数：可以像数组一样初始化</p>
<p>多参数，类似结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle circles[2] = &#123;Circle(1,1),Circle(1,1)&#125;</span><br></pre></td></tr></table></figure>

<p>#　类与对象的成员</p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">目的：程序优化，展开函数代码而不是调用</span><br><span class="line">内联函数使用的注意事项：</span><br><span class="line">	在函数定义前添加　inline关键字，仅在函数原型前使用此关键字无效。</span><br><span class="line">	编译器必须能看见内联函数的代码才能在编译期展开，内联函数必须实现在头文件中。</span><br><span class="line">	在类定义中给出函数体的成员函数自动成为内联函数。</span><br><span class="line">	构造函数和析构函数有可能隐含附加操作，慎用内联</span><br><span class="line">	内联函数仅是建议，　编译器会自助选择是否内联</span><br><span class="line">	函数体代码量较大，或包含循环，不要使用内联</span><br></pre></td></tr></table></figure>

<h5 id="内联函数定义"><a href="#内联函数定义" class="headerlink" title="内联函数定义"></a>内联函数定义</h5><p>​        inline是C++语言中的一个关键字，可以用于程序中定义内联函数，inline的引进使定义内联函数的定义更加简单，</p>
<p>​        内联函数，是C++中的一种特殊函数，它可以像普通函数一样被调用，但是在调用时并不通过函数调用机制，而是通过将函数体直接插入调用处来实现的，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率，一般inline用于定义类的成员函数</p>
<h4 id="inine的基本使用"><a href="#inine的基本使用" class="headerlink" title="inine的基本使用"></a>inine的基本使用</h4><p>inline的使用比较简单，只需要在声明或者定义时在头部加上inline关键字即可，格式如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span>　返回值　函数名（参数）｛</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>一般来说　,inline适用的函数有两种，一种是在类内定义的成员函数，另一种是在类内声明，类外定义的成员函数，</p>
<p>(1)类内定义成员函数</p>
<p>​    这种情况下，我们可以不用在函数头部加inline关键字，因为编译器会自动将类内定义的函数声明为内联函数，代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">temp</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">int</span> amount;</span><br><span class="line">    temp(<span class="keyword">int</span> amount)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;amout = amout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通成员函数，在类内定义时前面可以不加inline</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_amount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>-&gt;amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可看出，在类内定义函数时，可以不加inline关键字，编译器会自动将类内定义的函数(构造函数，析构函数，普通成员函数)设置为内联，具有内联函数调用的性质，</p>
<p>（２）类内声明函数，在类外定义函数</p>
<p>​            根据C++编译器的规则，这种情况下如果将该函数设置为内联函数，则可以在类内声明时不加inline关键字，而在类外定义时候加上关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">temp</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">int</span> amount;</span><br><span class="line">   	temp(<span class="keyword">int</span> amount)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;aout=amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_amount</span><span class="params">()</span></span>;<span class="comment">//普通成员函数，在类内声明前面可以不加ｉｎｌｉｎｅ</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> temp::print_amount()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;amount&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码我们可以看出，类内声明可以不用加上inline关键字，但是类外定义时必须加上，这样才能保证编译器能够识别其为内联函数。    </p>
<p>​    另外，我们可以在声明函数和定义函数的同时写inline,　也可以在声明时加，定义时不加，只要在调用该函数之前把inline的信息告知编译系统，编译系统就会在处理函数调用时按内联函数处理。也就是说，上面说的几种方法都可以实现一个内联函数的定义，根据自己的需要来写即可。</p>
<h4 id="3-内联函数的优缺点"><a href="#3-内联函数的优缺点" class="headerlink" title="3.内联函数的优缺点"></a>3.内联函数的优缺点</h4><p>优点：</p>
<p>​        １.inline定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换，没有了调用的开销，效率也很高。</p>
<p>​        ２.很明显，类的内联函数是一个真正的函数，编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确，然后进行一系列的相关检查，就像对待任何一个真正的函数一样，这样就消除了它的隐患和局限性，</p>
<p>​        ３．inline函数可以作为一个类的成员函数，与类的普通成员函数作用相同，可以访问一个类的私有成员和保护成员，类联函数可以用于替换一般的宏定义，最重要的应用在于类的存取函数的定义上面。</p>
<p>缺点：</p>
<p>​        １.内联函数具有一定的局限性，内联函数的函数体一般来说不能太大，如果内联函数的函数体过大，一般编译器会放弃内联方式，而采用普通的方式调用函数，</p>
<p>​        ２．ｉｎｌｉｎｅ对于编译器来说只是一个建议，</p>
<p>###　４内联函数和宏定义的区别</p>
<p>​        内联函数和宏的区别在于，</p>
<p>​        宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。</p>
<p>​        而且内联函数是真正的函数，只是在需要用到的时候，内联函数回想宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销，</p>
<p>​        你可以像调用函数一样来调用内联函数，而不必担心处理宏的一些问题，内联函数与带参数的宏定义进行下比较，他们的代码效率是一样的，但是内联函数遵循的类型和作用于规则，它与一般函数更相近，在一些编译器中，一旦关联上内联扩展，将与一般函一样进行调用，比较方便。</p>
<p>​        另外，宏定义在使用时只是简单的文本替换，并没有做严格的参数检查，也就不能享受Ｃ＋＋编译器的严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p>
<p>​        Ｃ＋＋的内联就是为了完全取代了宏定义，，，ｅｆｆｅｃｔｉｖｅ　Ｃ＋＋</p>
<p>中提到了尽量使用ｉｎｌｉｎｅ代替宏定义。</p>
<h3 id="5使用注意事项"><a href="#5使用注意事项" class="headerlink" title="5使用注意事项"></a>5使用注意事项</h3><p>１.内联函数不能包括复杂的控制语句，如循环语句和ｓｗｉｔｃｈ语句</p>
<p>２.内联函数不能包括复杂的控制语句，如循环语句和ｓｗｉｔｃｈ语句</p>
<p>３.只将规模很小，而使用频繁的函数声明为内联函数，在函数规模很小的　情况下，函数调用时间开销可能甚至超过执行函数本身的时间。</p>
<h3 id="常数据成员"><a href="#常数据成员" class="headerlink" title="常数据成员"></a>常数据成员</h3><p>常数据成员：值在程序运行期间不可变</p>
<p>定义格式：const 类型　　数据成员名称；</p>
<p><strong>初始化：只能通过构造函数中的初始化列表进行</strong></p>
<h3 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h3><p>不能修改对象成员值的函数</p>
<p>－定义格式：类型　　成员函数名称(参数列表)　　const;</p>
<p>－常成员函数不能调用类中非常成员函数</p>
<p>－静态成员函数不能定义为常成员函数</p>
<p>－如果对象为常量，则只能调用其常成员函数。</p>
<h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><p>静态数据成员只有一份，由该类所有对象共享，</p>
<p>－声明格式：static　类型　静态数据成员名称</p>
<p>－仅声明，　不在对象上分配空间</p>
<p>－定义格式：　类型　类名称::静态数据成员名称　＝　　初始值</p>
<p>－必须在外部初始化，初始化与访问控制无关</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;			</span><br><span class="line"><span class="keyword">int</span> A::count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><p>－在类而不是对象上调用</p>
<p>－目的：访问类的静态数据成员，若要访问类的非静态数据成员，必须制定对象或者使用指向对象的指针。</p>
<h2 id="单子模式"><a href="#单子模式" class="headerlink" title="单子模式"></a>单子模式</h2><p>只存在某类的单一共享对象</p>
<p>存在某种全局访问策略，以在需要时访问对象</p>
<p>程序中只存在一个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单子模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> SAingle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="继承的基本概念"><a href="#继承的基本概念" class="headerlink" title="继承的基本概念"></a>继承的基本概念</h4><p>类类型：描述分类的概念</p>
<p>继承：描述类之间的血缘关系</p>
<p>基类，派生类：</p>
<p>父类，子类</p>
<p>继承的意义</p>
<p>－派生类可以拥有基类的全部属性和行为，可以添加自己的属性和行为。</p>
<p>只能添加新的功能不能取消已有的！！**</p>
<p>###　单继承</p>
<p>class 派生类名称: 派生类保留字　基类名称{};</p>
<p><strong>保留字</strong></p>
<p>public:</p>
<p>​    基类的ｐｕｂｌｉｃ，ｐｒｏｔｅｃｔｅｄ成员在派生类中不可见</p>
<p>protected </p>
<p>​        基类的ｐｒｉｖａｔｅ成员在派生类中不可见，ｐｕｂｌｉｃ，ｐｒｏｔｅｃｔｅｄ变为ｐｒｏｔｅｃｔｅｄ</p>
<p>private</p>
<p>​        基类的ｐｒｉｖａｔｅ成员在派生类中间那个不可见，ｐｕｂｌｉｃ，ｐｒｏｔｅｃｔｅｄ成员在派生类中间那个变为ｐｒｉｖａｔｅ成员</p>
<p>－设计类时若需要使用继承机制，建议将派生类需要频繁使用的基类设为ｐｒｏｔｅｃｔｅｄ。</p>
<p>###　函数的覆盖与二义性</p>
<p>１．派生类成员函数名称与基类相同</p>
<p>　　如果派生类要调用基类的同名成员函数</p>
<p>pt.Point::Print()</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承的基本语法格式</p>
<p>class 派生类名称:派生类型保留字　　基类名称１　派生类型保留字　基类名称２，。。｛｝</p>
<p>多继承导致问题：派生类中可能有多个基类副本</p>
<p>class A{}; class　Ｂ:public A{};</p>
<p>class C:public A,protected  B{};</p>
<p>二义性　　同单继承差不多</p>
<p>d.B::A::f()</p>
<h3 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h3><p>目的:取消多继承时派生类中　公共基类的多个副本，只保留一份</p>
<p>格式：派生时使用关键字　virtual　</p>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;<span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;<span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span><span class="keyword">public</span> B,<span class="keyword">public</span> C&#123;<span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;;</span><br></pre></td></tr></table></figure>

<p>Ｂ类的对象上所有Ａ类副本只有一个</p>
<p>Ｃ类的对象上所有Ａ类副本只有一个</p>
<p>Ｄ类只有Ａ类的一个副本</p>
<h3 id="派生类的构造函数和析构函数"><a href="#派生类的构造函数和析构函数" class="headerlink" title="派生类的构造函数和析构函数"></a>派生类的构造函数和析构函数</h3><p>构造函数的执行顺序</p>
<p>－调用基类的构造函数，调用孙旭与基类在派生类中j</p>
<p>－调用派生类新增对象成员的构造函数，调用顺序与其在派生类中的定义顺序相同。</p>
<p>－调用派生类的构造函数；</p>
<p>析构函数的执行顺序</p>
<p>－调用派生类的析构函数</p>
<p>－调用派生类新增对象成员的析构函数，调用书序与其在派生类中定义顺序相反</p>
<p>－调用基类的析构函数，调用顺序与</p>
<h3 id="类的赋值兼容性"><a href="#类的赋值兼容性" class="headerlink" title="类的赋值兼容性"></a>类的赋值兼容性</h3><p>公有派生时，任何基类对象可以出现的位置都可以使用派生类对象代替。</p>
<p>－将派生类对象赋值给积累对象，仅赋值基类部分</p>
<p>－用派生类对象<strong>初始化基类对象引用</strong>，仅操作基类部分</p>
<p>－<strong>使指向基类的指针指向派生类对象</strong>，仅引领基类部分</p>
<p>００１２</p>
<p>保护派生与私有派生不可以直接赋值</p>
<p>－尽量不要使用保护派生与私有派生。　</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态性:</p>
<p>－目的：不同对象在接受到相同消息时做不同响应</p>
<p>－现象：对应同样成员函数名称，执行不同函数体</p>
<p>多态性的实现</p>
<p>－虚函数：使用ｖｉｒｔｕａｌ关键字声明成员函数</p>
<p>－声明格式:　virtual 函数返回值　函数名称(参数列表)；</p>
<p>效果：指向基类的指针，自动调用目标类</p>
<p>如果基类中有一个虚函数，派生类不想用？不写就行了</p>
<p><strong>纯虚函数</strong></p>
<p>－充当占位函数，没有任何实现</p>
<p>－派生类负责实现其具体功能</p>
<p>比如ａｃｃｏｕｎｔ实际上是不存在的　实际上　用的要么是ｃｈｅｃｋｉｎｇ　要么是ｓａｖｉｎｇ</p>
<p>声明格式:virtual void f(int x) = 0;//纯虚函数不能调用，但是其指针是存在的，</p>
<p><strong>抽象类</strong></p>
<p>－带有纯虚函数的类　//绝对不可能构造这样的一个对象</p>
<p>-作为类继承层次的上层。</p>
<p>虚析构函数</p>
<p>－保持多态性需要虚析构函数，以保证能够正确释放对象。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/分布式计算4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/分布式计算4/" class="post-title-link" itemprop="url">分布式计算4</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:38" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基于消息中间件的通信技术"><a href="#基于消息中间件的通信技术" class="headerlink" title="基于消息中间件的通信技术"></a>基于消息中间件的通信技术</h2><p>OMO     点对点</p>
<p>面向消息中间件：提供了一种分布式消息队列服务，使得节点之间可以实现基于消息的形式灵活的异步通信。</p>
<p>异步的含义</p>
<p>​    发送方可以在任意时刻发出消息不必等待接收方上线，不必等待发送成功</p>
<p>​    接收方不必以阻塞方式等待消息的到来</p>
<p>三种接收方式</p>
<p>​    阻塞方式</p>
<p>​    轮询模式　　ｔｉｍｅｏｕｔ＝＝０</p>
<p>​    回调接收　　异步　主动通知</p>
<p>　URL - factory - connection - session queue consumer</p>
<p>   jms 访问各类消息队列中间件的api</p>
<p>  面向接口编程：  先把接口商量好，定义一组interface，各自实现类，类实现接口。</p>
<p>MOM触发你的onMessage的调用 不是consumer调用  onMessage处理消息。</p>
<p>37行 pause， </p>
<p>运行：先启动消息中间件  activemq  队列也可以有多个消费者，但是，只有一个获取消息 拿了就没了</p>
<h2 id="基于主题发布-订阅通信编程实例"><a href="#基于主题发布-订阅通信编程实例" class="headerlink" title="基于主题发布/订阅通信编程实例"></a>基于主题发布/订阅通信编程实例</h2><p>Publisher —-&gt;Topic—-&gt;subscriber</p>
<p>URL—&gt;FACTORY—&gt;CONNECTION–&gt;SESSION–&gt;TOPIC</p>
<p>异步通信，可以减少系统响应时间，提高吞吐量</p>
<p>分布式节点之间的解耦</p>
<p>保证消息的可靠递交，中间件保证消息尽量可以交给接受者。  实现最终一致性</p>
<p>实现广播，组播和多对多通信</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/分布式计算3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/分布式计算3/" class="post-title-link" itemprop="url">分布式计算3</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:36" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第二讲分布式节点之间的通信技术"><a href="#第二讲分布式节点之间的通信技术" class="headerlink" title="第二讲分布式节点之间的通信技术"></a>第二讲分布式节点之间的通信技术</h2><p>##　底层通信技术</p>
<h3 id="基于TCP的点对点通信技术"><a href="#基于TCP的点对点通信技术" class="headerlink" title="基于TCP的点对点通信技术"></a>基于TCP的点对点通信技术</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">·数据链路层，点对点通信，真实物理的点对点</span><br><span class="line">·传输层：知道另外一个主机的IP,就想直接和他建立连接，对于TCP来说，直接建立逻辑管道，点对点，？</span><br><span class="line">·路由器没有传输层协议，只有网络层及其以下，只在主机上实现传输层协议，点对点。至于谁负责实现？ 操作系统</span><br><span class="line">·七层协议，流量控制，数据链路，传输层，</span><br><span class="line">·IP地址定位主机，端口号定义</span><br><span class="line">·UDP不应答，不作流量控制，</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">socket？？</span><br><span class="line">是传输层给应用层提供的一套  标准化编程接口</span><br><span class="line">					Application layer</span><br><span class="line">						process</span><br><span class="line">						--socket--</span><br><span class="line">					Transport layer</span><br><span class="line">					Network layer</span><br><span class="line">					Link layer</span><br><span class="line">					Physical layer</span><br><span class="line">	不但允许应用层访问传输层，也可以直接访问网络层</span><br><span class="line"></span><br><span class="line">类型  流式套接字，数据报套接字，原始套接字</span><br><span class="line">		APPLICATION</span><br><span class="line">stream socket interface  Datagram socket interface  Rawsocket interface</span><br><span class="line">TCP						UDP									|</span><br><span class="line">				IP</span><br><span class="line">				data link layer</span><br><span class="line">				</span><br><span class="line">如何标识一个Socket？  --指的是逻辑管道</span><br><span class="line">五元组&lt;sIP,sPort,dIP,dPort,协议&gt;</span><br><span class="line">	本地IP地址，本地端口号（1024-5000），远程IP地址，远程端口号（需要知道）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TCP套接字典型模型</span><br><span class="line">									服务器</span><br><span class="line">									创建套接字socket</span><br><span class="line">									绑定服务器地址和端口bind</span><br><span class="line">									监听端口Listen</span><br><span class="line">创建套接字 socket</span><br><span class="line">连接服务器 connect    ---------接受客户端连接accept</span><br><span class="line">客户端发送请求 write  ---------接受客户端请求 read</span><br><span class="line">客户端接受响应 read	--------回送响应write</span><br><span class="line">关闭套接字 close</span><br><span class="line"></span><br><span class="line">服务器端每次两个socket  一个用于三次握手用来对接，然后新生成一个</span><br><span class="line">监听socket and 客户socket</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">socket的最初设计，面向BSD UNIX-BERKLEY 面向TCP/IP协议栈接口</span><br><span class="line">目前 事实上的工业标准，绝大多数操作系统都支持。</span><br><span class="line">套接字api是internet环境中网络应用程序最常用的api接口，</span><br><span class="line">开发客户/服务器程序的最典型的手段。</span><br><span class="line">client-sever是最基础的通信模型。</span><br><span class="line">应用进程之间通信的抽象机制。</span><br><span class="line">通常来说，在一个主机上，应用层可能运行了很多应用进程，而每一个服务器应用进程为了能够支持客户端通信，必须创建套接字，一个进程通常可能会创建多个套接字。</span><br><span class="line">当客户创建一个套接字期望与某一个应用进程进行通信。怎样说明要与哪一个服务器端的套接字进行通信。单靠一个ip地址是不行的。</span><br><span class="line"></span><br><span class="line">客户端应用进程和服务器端应用进程都是与传输层协议进行交互，需要端口号。</span><br><span class="line">所以  IP地址＋端口号。</span><br><span class="line">对一个套接字，对外需要IP地址＋端口号</span><br><span class="line">操作系统/进程管理套接字（对内</span><br><span class="line">	套接字描述符  socket descriper</span><br><span class="line">	小整数</span><br><span class="line">当应用进程创建套接字，操作系统会分配一个数据结构存储相关信息，返回套接字描述符</span><br><span class="line">socket 可以进行同一主机不同进程之间的通信。more and more popular</span><br></pre></td></tr></table></figure>

<h3 id="基于UDP的点对点通信技术"><a href="#基于UDP的点对点通信技术" class="headerlink" title="基于UDP的点对点通信技术"></a>基于UDP的点对点通信技术</h3><h2 id="并发服务技术"><a href="#并发服务技术" class="headerlink" title="并发服务技术"></a>并发服务技术</h2><p>  如何使服务端同时处理多个客户端请求？</p>
<p>  基于多线程的并发服务技术。：程序好懂 好编，创建和销毁线程的代价太大。</p>
<p>基于线程池的threadpoolExecutor</p>
<h2 id="上层通信技术"><a href="#上层通信技术" class="headerlink" title="上层通信技术"></a>上层通信技术</h2><h3 id="远程过程调用RPC-远程方法调用RMI"><a href="#远程过程调用RPC-远程方法调用RMI" class="headerlink" title="远程过程调用RPC/远程方法调用RMI"></a>远程过程调用RPC/远程方法调用RMI</h3><p>​    我能够调用别的计算机上的对象的方法（远程方法调用），</p>
<h3 id="基于分布式消息队列的通信技术"><a href="#基于分布式消息队列的通信技术" class="headerlink" title="基于分布式消息队列的通信技术"></a>基于分布式消息队列的通信技术</h3><h3 id="WebService技术"><a href="#WebService技术" class="headerlink" title="WebService技术"></a>WebService技术</h3>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/分布式计算/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/分布式计算/" class="post-title-link" itemprop="url">分布式计算1</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:34" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>分布式共识系统</p>
<p>区块链，比较低效的分布式共识</p>
<p>比特币本质上是分布式系统，拿出以前的分布式系统，炒作手段？？？–</p>
<p>对于IT界和国民经济的推动没有那么大，本质上就是分布式系统，早就有了。。</p>
<p>2017年腾讯  paxos</p>
<p>2014 Raft</p>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>​    分布式系统的基本概念，模型和架构</p>
<p>​    分布式系统中的通信技术</p>
<pre><code>### 并发编程技术：</code></pre><p>​            B给A发消息 m1  同时C给A发消息 M2. 处理，？？</p>
<p>​            Ⅰ队列  但是没能完全利用A的能力，可能A多核 本可以同时处理两条消息 同时服务。</p>
<p>​            Ⅱ 开线程</p>
<p>​            Ⅲ  在linux 内核层  进程==线程，早期用多进程来实现并发服务。B的消息来了创建一个新的进程。。。</p>
<p>​            现在提供API   用进程模拟线程。。。实际上是多进程。</p>
<h4 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h4><p> 编程简单，但是  创建进程和线程开销很大，可能处理消息10ms  但是创建线程花了100ms，</p>
<p>​                           开的线程多，线程切换的开销也很大。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>​    减少线程创建和销毁的开销， 线程太多，频繁切换线程，效率降低了，</p>
<h4 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h4><p>​    多路复用模型，</p>
<p>​    S1  包括了 T1 T2 T3 子任务</p>
<p>​    S2  包括K1 K2 K3                     调度器                        线程1 线程2  线程 N     </p>
<p>​            几个核就几个线程，线程永不休眠，调度器负责安排子任务交由各个线程，某个线程并不是专门为哪一个请求服务的，可能一会S1 一会S2，</p>
<p>####　分别　</p>
<p>视具体应用情景。  比如程序里面有I/O 就能让调度器进行工作，（这种情况下可以区分出子任务  操作系统中，用户态和内核态，  进入内核态可以随意访问 计算机的I.O资源，  应用程序I/O动作需要切换到内核态， 调度器以此来区分）</p>
<p>####　协程</p>
<p>​    比线程更小的一种调度单位， 进程（线程（协程</p>
<p>​    OS负责切换和调度进程和线程的切换都有操作系统负责，协程的切换由应用层自己负责切换，调度。</p>
<p>​    OS 切换进程线程的基础是时钟中断。  另外是进程线程主动放弃CPU</p>
<p>​    应用层怎么实现协程序直接的切换？</p>
<p>​    nowadays 编译器自动嵌入代码   协程的切换调度嵌入。</p>
<p>​    example ， go 语言   </p>
<p>go  f1  go f2   这两个函数就并发执行了。。。</p>
<p>逻辑依赖部分。</p>
<h4 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h4><p>来一个用户请求，  启动一个虚拟机， </p>
<p>​    命名和表示问题的处理</p>
<p>​    时钟问题的处理</p>
<p>​    分布式协作中的基本算法</p>
<p>​    分布式共识算法</p>
<p>​    分布式事务处理</p>
<p>​    常用的分布式计算平台和编程模型，Map-Reduce，DAG，Streaming</p>
<p>操作系统（进程 线程 虚拟内存管理（每个应用程序有独立地址空间）， API 与系统调用， 用户态 内核态 文件系统，时钟，中断）</p>
<p>计算机网络</p>
<p>java编程语言</p>
<p>网络编程（Socket编程）</p>
<p># </p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/分布式2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/分布式2/" class="post-title-link" itemprop="url">分布式计算2</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:30" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="分布式系统构架模式"><a href="#分布式系统构架模式" class="headerlink" title="分布式系统构架模式"></a>分布式系统构架模式</h4><p>1 客户端-服务器模式   Client-Server</p>
<p>2 主-从模式   Mastr-Slave</p>
<p>3 总线模式</p>
<p>4 对等模式     Peer-to - Peer</p>
<h5 id="Client-server"><a href="#Client-server" class="headerlink" title="Client-server"></a>Client-server</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">客户端发出服务请求，服务器端根据客户端的请求参数完成实际的运算，返回运算结果。 </span><br><span class="line">客户端运算任务轻，服务器端重</span><br><span class="line">客户端生命周期短，服务器端生命周期长，</span><br><span class="line">服务器端一般要应对并发问题</span><br><span class="line">client一般负责和用户进行交互。</span><br><span class="line">客户端的处理能力弱，仅仅作为显示结果，交互。。</span><br><span class="line">胖客户端--处理能力强，本身可以完成某些计算，实在不行交给server</span><br><span class="line">BS  brower---server   HTTP  HTML</span><br><span class="line">CS  客户端软件是自己弄得</span><br></pre></td></tr></table></figure>

<p>client-cluster</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">是client - server的变种</span><br><span class="line">服务器端多个服务器构成，共同分担计算任务</span><br><span class="line">宏观逻辑上，多个服务器构成的集群可以视为单一的功能更强大的计算节点，客户端感觉不到服务器端的构成。</span><br></pre></td></tr></table></figure>

<p>三层结构Client-cluster模式</p>
<p>表示层 应用层，数据层</p>
<p>web服务器叫表示层，负责表示给用户</p>
<p>应用层 不负责直接存储和管理数据，做核心逻辑运算，</p>
<p>数据层 专门存储</p>
<p>任何软件分层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">缺点：层数太多，影响效率</span><br><span class="line">假定 业务逻辑更改，更改应用层</span><br><span class="line">页面太丑。。改表示层</span><br><span class="line">常识性：三层构架`-`</span><br></pre></td></tr></table></figure>

<p>对于客户端来说，只知道web服务器的IP地址</p>
<p>对于客户端来说，这种分层是透明的，</p>
<h3 id="对等分工结构-负载均衡架构"><a href="#对等分工结构-负载均衡架构" class="headerlink" title="对等分工结构/负载均衡架构"></a>对等分工结构/负载均衡架构</h3><p>负载均衡服务器和后台服务器。</p>
<p>组成以太网， 负载均衡器连一个交换机，双网卡</p>
<p>每个后台服务器一个网卡，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">客户端来一个请求，给负载均衡器，负载均衡器将请求分配给某一个后台服务器。服务结果返回给负载均衡器。</span><br><span class="line">薄弱点是负载均衡器，负载均衡器是性能瓶颈+ 单点失效点。  后台直接路由器，结果直接返回客户端。（IP地址欺骗，否则客户端会丢弃结果数据包）</span><br><span class="line">瓶颈转到路由器，负载均衡器工作在应用层。</span><br><span class="line">路由器里边不用实现传输层协议。  只有Pc机上需要实现传输层协议。</span><br><span class="line">回来的数据包从路由器过，只过三层，物理 链路，网络</span><br><span class="line">这种方式可以提高效率。</span><br></pre></td></tr></table></figure>

<h3 id="负载均衡器常用均衡策略"><a href="#负载均衡器常用均衡策略" class="headerlink" title="负载均衡器常用均衡策略"></a>负载均衡器常用均衡策略</h3><p>1 随机 2 轮询 3 固定权重+轮询（三台服务器的配置未必一样）<br>nginx web服务器。稍加配置作为一个负载均衡器。</p>
<p>支持1 2 3 IP哈希</p>
<p>IP哈希（给予一致性随即散列函数）</p>
<p>IP地址作为哈希函数的输入，取模。哈希函数也叫一致性随机散列函数</p>
<p>最少TCP连接数。负载均衡器看建立起来还未关闭的tcp连接数用来判断服务器的负载。</p>
<p>服务器跑一个小程序，收集服务器的负载，cpu利用率，中断次数，信息返回给负载均衡器，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有些web网站需要先登录，假定客户端3发送一个登陆请求，登陆成功，服务器1记录合法用户。客户端发送成绩查询请求，负载均衡器把这个请求给服务器2，服务器2认为是非法用户</span><br></pre></td></tr></table></figure>

<p>##　ＭＡＳＴＥＲ－ＳＬＡＶＥ模式</p>
<p>高性能分布式计算，处理系统中进场采用的一种架构模式</p>
<p>主节点（ＭＡＳＴＥＲ）　负责将总计算任务分解为多个子任务分发给各位从结点完成</p>
<p>主节点监视各个从结点的任务执行情况，将执行失败的任务调度给其他的从结点完成，</p>
<p>主节点在分配任务是会参考各个从节点的当前负载情况。</p>
<p>单点失效点是主节点。master结点会给备份结点，挂了备份节点上。</p>
<p>ＭＡＰ－ＲＥＤＵＣＥ</p>
<p>ＳＰＡＲＫ</p>
<p>ＴＥＮＳＯＲ－ＦＬＯＷ</p>
<h2 id="总线模式"><a href="#总线模式" class="headerlink" title="总线模式"></a>总线模式</h2><p>发布订阅模式</p>
<p> ·不同结点之间通过虚拟总线相连</p>
<p>消息发送者不必知道接受者是谁，接受者也不知道发送者是谁</p>
<p>发送者和接受者异步方式通信。</p>
<p>一中松耦合架构</p>
<p>不同结点完成不同功能。分工协作。</p>
<p>peer-to-peer模式</p>
<p>系统中每个计算节点在任务分工上是完全对等的。</p>
<p>完全相同的软件在不同的计算机上运行，只是初始化的参数不一样</p>
<p>结构化P2P：不同节点之间的交互模式遵循固定规律。</p>
<p>​    只和固定的结点打交道。</p>
<p>非结构化P2P：不同结点之间的交互模式没有固定规律。 </p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/第一讲 概论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/28/第一讲 概论/" class="post-title-link" itemprop="url">计算机网络-概论</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-28 17:13:43 / 修改时间：17:21:53" itemprop="dateCreated datePublished" datetime="2019-07-28T17:13:43+08:00">2019-07-28</time>
            </span>
          

          
            

            
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/学习笔记/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-1网络内涵"><a href="#1-1网络内涵" class="headerlink" title="1.1网络内涵"></a>1.1网络内涵</h1><h2 id="网络特征"><a href="#网络特征" class="headerlink" title="网络特征"></a>网络特征</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">共享资源：</span><br><span class="line">	互联计算机的目的是为了实现资源共享，这些资源包括软件、硬件和数据。</span><br><span class="line"></span><br><span class="line">自治系统：</span><br><span class="line">	自治系统是能够独立运行并提供服务的系统，连接到计算机网络中的每个设备都应该是自治系统。</span><br><span class="line">	</span><br><span class="line">遵守同一的通信标准：</span><br><span class="line">	·互联这些自治系统的目的是为了实现资源共享</span><br><span class="line">	·实现资源共享就必须相互交换数据</span><br><span class="line">	·相互交换数据就必须遵守同一的通信标准。</span><br></pre></td></tr></table></figure>

<h3 id="计算机网络：-以实现资源共享为目的，一些互相连接的、独立自治的计算机的集合。"><a href="#计算机网络：-以实现资源共享为目的，一些互相连接的、独立自治的计算机的集合。" class="headerlink" title="计算机网络： 以实现资源共享为目的，一些互相连接的、独立自治的计算机的集合。"></a>计算机网络： 以实现资源共享为目的，一些互相连接的、独立自治的计算机的集合。</h3><h2 id="网络定义"><a href="#网络定义" class="headerlink" title="网络定义"></a>网络定义</h2><h1 id="1-2互联网发展过程"><a href="#1-2互联网发展过程" class="headerlink" title="1.2互联网发展过程"></a>1.2互联网发展过程</h1><h2 id="从ARPA网络到internet"><a href="#从ARPA网络到internet" class="headerlink" title="从ARPA网络到internet"></a>从ARPA网络到internet</h2><p>~1969年，互联网雏形ARPANET诞生</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    2o世纪80年代中后期，计算机网络是行业内认识或企业内参与信息管理系统开发的人士所关心的东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从技术层面讲：个人电脑，交换机和路由器，Web技术的诞生和发展为Internet的兴起和发展提供了技术保障</span><br><span class="line">从市场层面讲：丰富的网络信息资源，尤其是网络的交互性，极大的提高了人们上网的积极性，网络彻底改变了人们的生活，工作方式。</span><br></pre></td></tr></table></figure>

<h2 id="从低速互联网到高速互联网"><a href="#从低速互联网到高速互联网" class="headerlink" title="从低速互联网到高速互联网"></a>从低速互联网到高速互联网</h2><p>~描述网络速度？</p>
<p>​    带宽：数据传输速率</p>
<p>​    传输速率：指网络中每秒发送或者接受的二进制位数，单位为比特每秒，缩写为b/s or bps 有时也称为比特率。</p>
<p>​    <strong>不同级别网络的速率要求不同</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="从数据网络到同一网络"><a href="#从数据网络到同一网络" class="headerlink" title="从数据网络到同一网络"></a>从数据网络到同一网络</h2><h2 id="从Internet到移动Internet"><a href="#从Internet到移动Internet" class="headerlink" title="从Internet到移动Internet"></a>从Internet到移动Internet</h2><h2 id="从Internet到物联网"><a href="#从Internet到物联网" class="headerlink" title="从Internet到物联网"></a>从Internet到物联网</h2><h2 id="从Internet到安全internet"><a href="#从Internet到安全internet" class="headerlink" title="从Internet到安全internet"></a>从Internet到安全internet</h2><h1 id="1-3交换方式"><a href="#1-3交换方式" class="headerlink" title="1.3交换方式"></a>1.3交换方式</h1><h1 id="1-4计算机网络体系结构和协议"><a href="#1-4计算机网络体系结构和协议" class="headerlink" title="1.4计算机网络体系结构和协议"></a>1.4计算机网络体系结构和协议</h1><h1 id="1-5网络分类"><a href="#1-5网络分类" class="headerlink" title="1.5网络分类"></a>1.5网络分类</h1>
          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/13/first/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="aaaaltaaaa">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博学之,审问之,慎思之,明辨之,笃行之">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/09/13/first/" class="post-title-link" itemprop="url">博客诞生记</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-13 20:46:25" itemprop="dateCreated datePublished" datetime="2016-09-13T20:46:25+08:00">2016-09-13</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-28 16:03:53" itemprop="dateModified" datetime="2019-07-28T16:03:53+08:00">2019-07-28</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>​    经过了漫长的等待，我终于开始了期待已久的大学生涯。</p>
<p>​    百无聊赖之中，我决定开始搭建自己的博客，并且记录我的生活，不为其他，只为给自己留一份回忆的书签。</p>
<p>​    经过短时间的了解，我决定使用<a href="https://pages.github.com" target="_blank" rel="noopener"><em>GitHub Pages</em></a>和<a href="https://hexo.io/" target="_blank" rel="noopener"><em>Hexo</em></a>来开始我的博客生涯，因为囊中羞涩且技术实力比较单薄，所以这个搭配可以说是比较适合我的了，gitpages不需要额外的费用，hexo的使用也比较简单，虽然有一些缺点，比如说只能使用静态的网站，gitpages有300M的限制等，这样的感觉就像是一个Makedown的转换器，但是对个人是用来将来说已经足够了。</p>
<p>​    通过阅读Hexo的官方文档和在知乎等处的搜索，我发现搭建一个博客远比想象的简单，只需傻瓜式的几步操作就可以搭建出一个简洁优雅的网站，所以我决定动手去做。大概花费了一个晚上的时间，博客就搭建完毕了，基本操作也熟悉了许多。</p>
<p>​    总而言之，这是我第一次尝试类似的事情，结果还是比较成功的，希望以后可以用来记录下我的生活与学习历程。</p>

          
        
      
    </div>

    

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">

          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  
    <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="aaaaltaaaa">
  
  <p class="site-author-name" itemprop="name">aaaaltaaaa</p>
  <div class="site-description motion-element" itemprop="description"></div>
</div>


  <nav class="site-state motion-element">
    
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    

    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>







  <div class="links-of-author motion-element">
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/aaaaltaaaa" title="GitHub &rarr; https://github.com/aaaaltaaaa" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>







          
          
        </div>
      </div>

      

      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaaaltaaaa</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>










  
  





  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>









  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>




  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>




  

  <script src="/js/next-boot.js?v=7.2.0"></script>

  

  

  

  

  

  

  

  

  



  




  




  




  






  

  

  


  

</body>
</html>
